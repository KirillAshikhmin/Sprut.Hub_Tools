{
  "scenarioTemplate": {
    "name": "BatteryMonitoring.Global",
    "desc": "",
    "active": true,
    "onStart": true,
    "sync": false,
    "data": "/**\n * Получает информацию о состоянии батарей всех устройств и отправляет сводку\n * @param {Boolean} fullInfo - Показывать полную информацию (включая устройства в норме и без логики)\n * @param {Array} blackList - Список ID устройств для исключения из проверки\n * @param {Array} whiteList - Список ID устройств для включения в проверку (если пустой, проверяются все)\n * @param {String} notificationChannel - Канал уведомлений (например, \"Telegram_1\", \"Web_1\")\n * @param {String} notificationClients - Строка с ID клиентов через запятую (например, \"1, 3, 4\")\n * @param {Boolean} silentNotification - Отправлять уведомление без звука\n */\nfunction getBatteriesInfo(fullInfo, blackList, whiteList, notificationChannel, notificationClients, silentNotification) {\n    // Параметры по умолчанию\n    var defaultFullInfo = false;                    // Показывать полную информацию (включая устройства в норме и без логики) - по умолчанию оказывать только разряженные батареи\n    var defaultBlackList = [];                      // Список ID устройств для исключения из проверки - по умолчанию не исключать устройства\n    var defaultWhiteList = [];                      // Список ID устройств для включения в проверку (если пустой, проверяются все) - по умолчанию проверять все устройства\n    var defaultNotificationChannel = \"Telegram_1\";            // Канал уведомлений (например, \"Telegram_1\", \"Web_1\") - по умолчанию канал не указан\n    var defaultNotificationClients = \"1\";            // Строка с ID клиентов через запятую (например, \"1, 3, 4\") - по умолчанию пустая строка\n    var defaultSilentNotification = false;          // Отправлять уведомление без звука - по умолчанию уведомления с звуком\n\n    const blackListAccessories = [];\n    const whiteListAccessories = [];\n\n    // Слияние переданных параметров с параметрами по умолчанию\n    var actualFullInfo = fullInfo !== undefined ? fullInfo : defaultFullInfo;\n    var actualBlackList = blackList !== undefined ? blackList : defaultBlackList;\n    var actualWhiteList = whiteList !== undefined ? whiteList : defaultWhiteList;\n    var actualNotificationChannel = notificationChannel !== undefined ? notificationChannel : defaultNotificationChannel;\n    var actualNotificationClients = notificationClients !== undefined ? notificationClients : defaultNotificationClients;\n    var actualSilentNotification = silentNotification !== undefined ? silentNotification : defaultSilentNotification;\n\n    let states = GlobalVariables[\"batteryStateScenario\"]\n    if (!states) GlobalVariables[\"batteryStateScenario\"] = []\n\n    let black = blackListAccessories\n    let white = whiteListAccessories\n    if (Array.isArray(actualBlackList)) { actualBlackList.forEach(function (i) { black.push(i) }) } else if (actualBlackList != undefined && actualBlackList.length > 0) black.push(actualBlackList)\n    if (Array.isArray(actualWhiteList)) { actualWhiteList.forEach(function (i) { white.push(i) }) } else if (actualWhiteList != undefined && actualWhiteList.length > 0) white.push(actualWhiteList)\n\n    let withLowBattery = []\n    let normalBattery = []\n    let withoutLogic = []\n    let batteries = {};\n    Hub.getAccessories().forEach(function (accessory) {\n        const uuid = accessory.getUUID()\n        if (white.length > 0 && white.indexOf(uuid) < 0) return\n        if (black.indexOf(uuid) >= 0) return\n        let service = accessory.getService(HS.BatteryService)\n        if (service == null) return\n        let state = GlobalVariables[\"batteryStateScenario\"][uuid]\n        if (state == undefined) {\n            const level = service.getCharacteristic(HC.BatteryLevel).getValue()\n            const charging = service.getCharacteristic(HC.ChargingState).getValue() == 1\n            const lowBattery = service.getCharacteristic(HC.StatusLowBattery).getValue()\n\n            state = {\n                uuid: uuid,\n                name: accessory.getName(),\n                room: accessory.getRoom().getName(),\n                manufacturer: accessory.getManufacturer(),\n                model: accessory.getModel(),\n                level: level,\n                lowBattery: lowBattery,\n                charging: charging,\n                logicEnabled: false\n            }\n        } else {\n            state.logicEnabled = true\n        }\n\n        if (state.lowBattery) withLowBattery.push(state)\n        else normalBattery.push(state)\n        if (state.logicEnabled != true) withoutLogic.push(state)\n        if (state.lowBattery && state.batteryType != undefined && state.batteryType != \"\") {\n            let count = batteries[state.batteryType]\n            if (count == undefined) count = state.quantity\n            else count += state.quantity\n            batteries[state.batteryType] = count\n        }\n\n    })\n    GlobalVariables.batteriesForChange = batteries\n\n    withLowBattery = withLowBattery.sort(function (a, b) { return a.room.localeCompare(b.room); })\n    normalBattery = normalBattery.sort(function (a, b) { return a.room.localeCompare(b.room); })\n    withoutLogic = withoutLogic.sort(function (a, b) { return a.room.localeCompare(b.room); })\n\n    let hasWithLowBattery = withLowBattery.length > 0\n    \n    // Формируем сообщение в зависимости от канала\n    let message = formatBatterySummaryMessage(withLowBattery, normalBattery, withoutLogic, batteries, actualFullInfo, actualNotificationChannel)\n    \n    // Преобразуем строку клиентов в массив\n    let clientsArray = []\n    if (actualNotificationClients && actualNotificationClients.trim() !== \"\") {\n        clientsArray = actualNotificationClients.split(',').map(client => client.trim()).filter(client => client !== \"\")\n    }\n    \n    // Отправляем уведомление через новую функцию\n    sendNotification(\n        message,\n        actualNotificationChannel,\n        clientsArray,\n        actualSilentNotification\n    )\n}\n\n/**\n * Функция для форматирования сводки по батареям в зависимости от канала\n * @param {Array} withLowBattery - Массив устройств с разряженными батареями\n * @param {Array} normalBattery - Массив устройств с нормальными батареями\n * @param {Array} withoutLogic - Массив устройств без активированной логики\n * @param {Object} batteries - Объект с типами батарей для замены\n * @param {Boolean} fullInfo - Показывать полную информацию\n * @param {String} channel - Канал уведомлений\n * @returns {String} Отформатированное сообщение\n */\nfunction formatBatterySummaryMessage(withLowBattery, normalBattery, withoutLogic, batteries, fullInfo, channel) {\n    if (channel && channel.startsWith(\"Telegram\")) {\n        // Форматирование для Telegram - сразу строка\n        let text = \"*🔋 Состояние батарей:*\\n\"\n        \n        if (withLowBattery.length > 0) {\n            text += \"❗️ *Разряжены:*\\n\"\n            withLowBattery.forEach(function (state) {\n                text += formatStateToTgString(state) + \"\\n\"\n            })\n\n            let batKeys = Object.keys(batteries)\n            if (batKeys.length > 0) {\n                text += \"\\n🔋  *Необходимо для замены:*\\n\"\n                batKeys.forEach(function (type) {\n                    text += type + \" \" + batteries[type] + \" шт.\\n\"\n                })\n            }\n        } else {\n            if (!fullInfo) text += \"Все батареи заряжены\\n\"\n        }\n        \n        if (fullInfo) {\n            if (normalBattery.length > 0 && withoutLogic.length > 0 && withLowBattery.length > 0) {\n                text += \"\\n####################################\\n\\n\"\n            }\n            if (normalBattery.length > 0) {\n                text += \"👌 *В норме:*\\n\"\n                normalBattery.forEach(function (state) {\n                    text += formatStateToTgString(state, true) + \"\\n\"\n                })\n            }\n\n            if (withoutLogic.length > 0) {\n                text += \"\\n🫵 *Устройства без активированной логики:*\\n\"\n                withoutLogic.forEach(function (state) {\n                    text += formatStateToTgString(state, true, true) + \"\\n\"\n                })\n            }\n        }\n        \n        return text\n    } else {\n        // Форматирование для других каналов\n        let text = \"\"\n        if (withLowBattery.length > 0) {\n            text += \"🔋❗️ Разряжённые батареи: \"\n            withLowBattery.forEach(function (state) {\n                text += formatStateToInfo(state)\n            })\n\n            let batKeys = Object.keys(batteries)\n            if (batKeys.length > 0) {\n                text += \"🔋 Необходимо для замены: \"\n                batKeys.forEach(function (type) {\n                    text += type + \" \" + batteries[type] + \" шт. \"\n                })\n            }\n        }\n        if (text == \"\") text = \"Все батареи заряжены\"\n        \n        return text\n    }\n}\n\nfunction formatStateToInfo(state) {\n    return state.room + \" -> \" + state.name +\n        (state.placement != \"\" && state.placement != undefined ? \". \" + state.placement.trim() : \"\") + \" (ID: \" + state.uuid + \")\" +\n        \" \" + state.level + \"% | \"\n}\n\nfunction formatStateToTg(textArray, state, compact, noShowLevel) {\n    if (compact == true) {\n        textArray.push(\n            state.room + \" -> \" + state.name +\n            (state.placement != \"\" && state.placement != undefined ? \". \" + state.placement.trim() : \"\") + \" (ID: \" + state.uuid + \")\" +\n            (!noShowLevel ? (\" *\" + state.level + \"%*\") : \"\")\n        )\n    } else {\n        textArray.push(state.room + \" -> \" + state.name + \" (ID: \" + state.uuid + \")\")\n        if (state.placement != undefined && state.placement != \"\") textArray.push(state.placement.trim())\n        textArray.push(\"Заряд: \" + state.level + \"%\")\n        if (state.batteryType != undefined && state.batteryType != \"\" && state.batteryType != \"-\") textArray.push(\"Тип: \" + state.batteryType + \" (\" + state.quantity + \" шт.)\")\n        if (state.chargingType != undefined && state.chargingType != \"\" && state.chargingType != \"-\") textArray.push(\"Заряжается через: \" + state.chargingType + \" \")\n        if (state.comment != undefined && state.comment != \"\") textArray.push(state.comment.trim())\n        if (state.date != undefined) textArray.push(\"Дата \" + (state.chargingType != \"\" ? \"зарядки\" : \"замены батареи\") + \": \" + state.date.replaceAll(\"-\", \".\"))\n        if (state.logicEnabled != true) textArray.push(\"Логика не активирована\")\n        textArray.push(\"\")\n    }\n}\n\n/**\n * Форматирует состояние устройства в строку для Telegram\n * @param {Object} state - Объект состояния устройства\n * @param {Boolean} compact - Компактный режим\n * @param {Boolean} noShowLevel - Не показывать уровень заряда\n * @returns {String} Отформатированная строка\n */\nfunction formatStateToTgString(state, compact, noShowLevel) {\n    if (compact == true) {\n        return state.room + \" -> \" + state.name +\n            (state.placement != \"\" && state.placement != undefined ? \". \" + state.placement.trim() : \"\") + \" (ID: \" + state.uuid + \")\" +\n            (!noShowLevel ? (\" *\" + state.level + \"%*\") : \"\")\n    } else {\n        let result = state.room + \" -> \" + state.name + \" (ID: \" + state.uuid + \")\\n\"\n        if (state.placement != undefined && state.placement != \"\") result += state.placement.trim() + \"\\n\"\n        result += \"Заряд: \" + state.level + \"%\\n\"\n        if (state.batteryType != undefined && state.batteryType != \"\" && state.batteryType != \"-\") result += \"Тип: \" + state.batteryType + \" (\" + state.quantity + \" шт.)\\n\"\n        if (state.chargingType != undefined && state.chargingType != \"\" && state.chargingType != \"-\") result += \"Заряжается через: \" + state.chargingType + \" \\n\"\n        if (state.comment != undefined && state.comment != \"\") result += state.comment.trim() + \"\\n\"\n        if (state.date != undefined) result += \"Дата \" + (state.chargingType != \"\" ? \"зарядки\" : \"замены батареи\") + \": \" + state.date.replaceAll(\"-\", \".\") + \"\\n\"\n        if (state.logicEnabled != true) result += \"Логика не активирована\\n\"\n        \n        return result\n    }\n}\n\n/**\n * Функция для отправки уведомлений через Notify\n * @param {String} message - Текст сообщения для отправки\n * @param {String} channel - Канал уведомлений (например, \"Telegram_1\", \"Web_1\")\n * @param {Array} clients - Массив идентификаторов клиентов\n * @param {Boolean} silent - Флаг тихого режима\n */\nfunction sendNotification(message, channel, clients, silent) {\n    try {\n        // Проверяем, что если заданы клиенты, то должен быть задан канал\n        if (clients && clients.length > 0 && (!channel || channel.trim() === \"\")) {\n            log.error(\"BatteryMonitoring: Заданы клиенты, но не указан канал уведомлений\")\n            return\n        }\n\n        // Создаем объект уведомления\n        let notify = Notify.text(message)\n            .debugText(\"BatteryMonitoring\")\n\n        // Устанавливаем тихий режим если нужно\n        if (silent) {\n            notify = notify.silent(true)\n        }\n\n        // Если заданы и канал, и клиенты, то настраиваем адресатов\n        if (channel && channel.trim() !== \"\" && clients && clients.length > 0) {\n            // Применяем клиентов по одному, так как spread operator не поддерживается\n            clients.forEach(function(client) {\n                notify = notify.to(channel, client)\n            })\n        }\n\n        // Отправляем уведомление\n        notify.send()\n    } catch (e) {\n        log.error(\"BatteryMonitoring: Ошибка отправки уведомления: \" + e.message)\n    }\n}",
    "type": "GLOBAL"
  }
}