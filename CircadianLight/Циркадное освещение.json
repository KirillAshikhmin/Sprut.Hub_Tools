{
  "scenarioTemplate": {
    "name": "Циркадное освещение",
    "desc": "Устанавливает температуру и яркость лампы в зависимости от времени суток. Значения берутся из глобального сценария. Изменить значения внутри режимов и добавить свои можно там же. Обновления по ссылке https://github.com/KirillAshikhmin/Sprut.Hub_Tools/tree/main/CircadianLight и в канале https://t.me/smart_sputnik",
    "active": true,
    "onStart": true,
    "sync": false,
    "data": "info = {\n  name: \"Циркадное освещение\",\n  description: \"Устанавливает температуру и яркость лампы в зависимости от времени суток. Значения берутся из глобального сценария. Изменить значения внутри режимов и добавить свои можно там же. Обновления по ссылке https://github.com/KirillAshikhmin/Sprut.Hub_Tools/tree/main/CircadianLight и в канале https://t.me/smart_sputnik\",\n  version: \"6.0\",\n  author: \"@BOOMikru\",\n\n  active: true,\n  onStart: true,\n  sync: false,\n\n  sourceServices: [HS.Lightbulb],\n  sourceCharacteristics: [HC.On, HC.Brightness, HC.ColorTemperature, HC.Hue, HC.Saturation],\n\n  options: {\n    Preset: {\n      name: {\n        en: \"Preset\",\n        ru: \"Режим работы\"\n      },\n      desc: {\n        en: \"Can change in Perams global scenario\",\n        ru: \"Изменить или добавить режим можно в глобальном сценарии 'Циркадное освещение. Глобальный. Параметры'\"\n      },\n      type: \"Integer\",\n      value: 0,\n      formType: \"list\",\n      values: global.getCircadianLightModes()\n    },\n    WhatChange: {\n      name: {\n        en: \"What сhange\",\n        ru: \"Что изменять\"\n      },\n      type: \"Integer\",\n      value: 0,\n      formType: \"list\",\n      values: [\n        { value: 0, name: { en: \"Brightness and temperature\", ru: \"Яркость и цветовую температуру\" } },\n        { value: 1, name: { en: \"Brightness\", ru: \"Только яркость\" } },\n        { value: 2, name: { en: \"Temperature\", ru: \"Только цветовую температуру\" } }\n      ]\n    },\n    Behavior: {\n      name: {\n        en: \"Behavior characteristic changes\",\n        ru: \"Поведение при изменении характеристики (яркости или температуры)\"\n      },\n      type: \"Integer\",\n      value: 0,\n      formType: \"list\",\n      values: [\n        { value: 0, name: { en: \"StopChar\", ru: \"Останавливать автоматическое изменение характеристики\" } },\n        { value: 1, name: { en: \"StopCircade\", ru: \"Останавливать циркадный режим\" } },\n        { value: 2, name: { en: \"Ignore\", ru: \"Игнорировать (в каждые 5 минут по часам будет восстанавливаться)\" } },\n        { value: 3, name: { en: \"Restore\", ru: \"Восстанавить циркадное значение сразу\" } }\n      ]\n    },\n    SmoothOnTime: {\n      name: {\n        en: \"Smooth on time (seconds)\",\n        ru: \"Время плавного включения (секунды)\"\n      },\n      desc: {\n        en: \"Time in seconds for smooth brightness transition when turning on. Set to 0 to disable. It is better to use the lamp's built-in setting if available.\",\n        ru: \"Время в секундах для плавного изменения яркости при включении. Установите 0 для отключения. Лучше использовать встроенную настройку лампы, если она доступна. Не использовать, если к этой лампе привязаны другие\"\n      },\n      type: \"Integer\",\n      value: 0,\n    },\n    LinkedBehavior: {\n      name: {\n        en: \"Behavior linked lamp\",\n        ru: \"Поведение при изменении характеристики у связанной лампы\"\n      },\n      desc: {\n        en: \"For example, when the circadian mode is activated in a chandelier that consists of 5 smart lamps. Not use if no has linked lamps\",\n        ru: \"Например когда циркадный режим активируется у люстры, которая состоит из 5 умных ламп. Не используется, если нет связанных ламп.\"\n      },\n      type: \"Integer\",\n      value: 0,\n      formType: \"list\",\n      values: [\n        { value: 0, name: { en: \"Stop\", ru: \"Останавливать автоматическое изменение характеристики\" } },\n        { value: 1, name: { en: \"Ignore\", ru: \"Игнорировать\" } },\n        { value: 2, name: { en: \"Restore\", ru: \"Восстанавить циркадное значение\" } }\n      ]\n    },\n    RandomSeconds: {\n      name: {\n        en: \"Random change time\",\n        ru: \"Случайное время изменения\"\n      },\n      desc: {\n        en: \"By default, the values ​​are set by the hour every 5 minutes. With this parameter, the value will be set to 5 minutes and 0-60 seconds. It is necessary if the script is activated for many lamps, to avoid the error 'The execution queue cannot be more than 5 values'\",\n        ru: \"По умолчанию значения устанавливаются по часам каждые 5 минут. С этим параметром значение будет устанавливаться в 5 минут и 0-59 секунд. Необходимо если сценарий активирован у многих ламп, что бы избежать ошибки 'Очередь на выполнение не может быть больше 5-и значений'\"\n      },\n      type: \"Boolean\",\n      value: false\n    },\n    ChangeTempDelay: {\n      name: {\n        en: \"Change temp after bright\",\n        ru: \"Менять температуру после яркости\"\n      },\n      desc: {\n        en: \"Set color temperature after one second  It is necessary if the script is activated for many lamps, to avoid the error 'The execution queue cannot be more than 5 values'\",\n        ru: \"Set the color temperature one second after setting the brightness. Необходимо если сценарий активирован у многих ламп, что бы избежать ошибки 'Очередь на выполнение не может быть больше 5-и значений'\"\n      },\n      type: \"Boolean\",\n      value: false\n    },\n    Debug: {\n      name: {\n        en: \"Debug\",\n        ru: \"Отладка\"\n      },\n      type: \"Boolean\",\n      value: false\n    }\n  },\n\n  variables: {\n    // Параметры запуска\n    startParameter: {\n      brightAtStart: -1,\n      isTurnOnByBright: false,\n      isTurnOnByTemp: false,\n      isTurnOnByHue: false,\n      isTurnOnBySat: false\n    },\n    // Параметры плавного включения\n    smoothOn: {\n      target: 1,\n      active: false,\n      task: undefined,\n    },\n    // Задача на обновление значения циркады\n    cronTask: undefined,\n    // Задача на восстановление циркады\n    reset: {\n      name: undefined,\n      task: undefined,\n    },\n    // Изменение параметров\n    changed: {\n      // Яркость изменена вручную\n      bright: false,\n      // Температура изменена вручную\n      temp: false,\n      // Оттенок изменен вручную\n      hue: false,\n      // Насыщенность изменена вручную\n      sat: false,\n    },\n    disabled: false,\n    runtime: {\n      stopped: false,\n      dontChangeBright: false,\n      dontChangeTemp: false,\n      dontChangeHue: false,\n      dontChangeSat: false,\n    }\n  }\n}\n\n\nfunction trigger(source, value, variables, options, context) {\n  const service = source.getService()\n  const isOn = source.getType() == HC.On\n  const isDebug = options.Debug\n  const behavior = options.Behavior\n\n  // Проверка выключения и сброса\n  const disableName = global.getCircadianLightGlobalVariableForDisable(service)\n  const resetName = global.getCircadianLightGlobalVariableForReset(source.getService())\n  variables.reset.name = resetName\n\n  if (isOn) {\n    if (value) {\n      GlobalVariables[resetName] = false\n\n      variables.reset.task = setInterval(function () {\n        // Выключили, останавливаем\n        if (GlobalVariables[disableName] == true && variables.disabled != true) {\n          debug(\"==== ОТКЛЮЧЕНИЕ ==== Циркадный режим отключен\", source, isDebug)\n          variables.disabled = true\n          stop(source, variables, options)\n          reset(variables)\n          return;\n        }\n        // Включили, возобновляем работу\n        if (GlobalVariables[disableName] == false && variables.disabled == true) {\n          debug(\"==== ВКЛЮЧЕНИЕ ==== Циркадный режим включен\", source, isDebug)\n          variables.disabled = false\n          // Включили, надо и перезапустить\n          GlobalVariables[resetName] = true\n        }\n\n        if (GlobalVariables[resetName] == true) {\n          GlobalVariables[resetName] = false\n          debug(\"==== СБРОС ==== Циркадный режим восстановлен\", source, isDebug)\n          reset(variables)\n          if (service.getCharacteristic(HC.On).getValue()) {\n            setCircadianValue(source.getService(), variables, options)\n            restartCron(source, variables, options)\n          }\n        }\n      }, 1000)\n    } else {\n      if (variables.reset.task) {\n        variables.reset.task.clear()\n        variables.reset.task = undefined\n      }\n    }\n  }\n\n  const disabled = GlobalVariables[disableName] == true || variables.runtime.stopped == true\n  if (isOn && !value) {\n    stop(source, variables, options, disabled)\n    reset(variables)\n\n    if (variables.reset.task) {\n      variables.reset.task.clear()\n      variables.reset.task = undefined\n    }\n    return\n  }\n\n  if (disabled) return\n\n  // Проверка способа включения\n  if (isOn && value) {\n    if (contain(context, \"Lightbulb.Brightness\") || variables.changed.bright) {\n      debug(\"Включается через изменение яркости на значение {}\", source, isDebug, service.getCharacteristic(HC.Brightness).getValue(), context)\n      variables.startParameter.isTurnOnByBright = true\n      variables.startParameter.brightAtStart = service.getCharacteristic(HC.Brightness).getValue()\n    }\n    if (contain(context, \"Lightbulb.ColorTemperature\") || variables.changed.temp) {\n      debug(\"Включается через изменение температуры на значение {}\", source, isDebug, service.getCharacteristic(HC.ColorTemperature).getValue(), context)\n      variables.startParameter.isTurnOnByTemp = true\n    }\n    if (contain(context, \"Lightbulb.Saturation\")) {\n      debug(\"Включается через изменение насыщенности на значение {}\", source, isDebug, service.getCharacteristic(HC.Saturation).getValue(), context)\n      variables.startParameter.isTurnOnByTemp = true\n      variables.startParameter.isTurnOnBySat = true\n    }\n    if (contain(context, \"Lightbulb.Hue\")) {\n      debug(\"Включается через изменение оттенки на значение {}\", source, isDebug, service.getCharacteristic(HC.Hue).getValue(), context)\n      variables.startParameter.isTurnOnByTemp = true\n      variables.startParameter.isTurnOnByHue = true\n    }\n  }\n\n  const isBright = source.getType() == HC.Brightness\n  const isTemp = source.getType() == HC.ColorTemperature\n  const isHue = source.getType() == HC.Hue\n  const isSaturation = source.getType() == HC.Saturation\n\n  let stopChange = false\n\n  // Проверка изменения параметров. Событие вызывается и при автоматической смене яркости\n  if (isBright || isTemp || isHue || isSaturation) {\n    let changeReason = getChageReason(context, source.getUUID())\n    let linkedCharacteristicType = undefined\n    let ignoreFromLinked = options.LinkedBehavior == 1 || changeReason.auto || (options.LinkedBehavior != 2 && variables.lastSetTime && (Date.now() - variables.lastSetTime < 1500))\n    if (changeReason.byLinkedLamp) {\n      if (ignoreFromLinked) { return; }\n      if (changeReason.linkedUUID) {\n        if (service.getCharacteristic(HC.On).getValue()) {\n          let linkedUUID = changeReason.linkedUUID\n          const cdata = linkedUUID.split('.');\n          const aid = cdata[0];\n          const sid = cdata[1];\n          let linkedService = Hub.getAccessory(aid).getService(sid)\n          linkedCharacteristicType = linkedService.getCharacteristic(cdata[2]).getType()\n\n          if (options.LinkedBehavior == 2) {\n            setCircadianValue(linkedService, variables, options, true, linkedCharacteristicType)\n            return\n          }\n          if (options.LinkedBehavior == 0) {\n            stopChange = true\n          }\n        }\n      }\n    } else {\n      if (behavior == 3) {\n        let lastSetTime = variables.lastSetTime\n        if (lastSetTime && ((Date.now() - lastSetTime) > 1500) && !changeReason.auto) {\n          setCircadianValue(service, variables, options, options.Debug)\n        }\n        return\n      }\n    }\n\n    let autoChange = changeReason.auto\n\n    // Если включено \"Останавливать автоматическое изменение характеристики\"\n    if (behavior == 0 || behavior == 1 || stopChange) {\n      if (variables.startParameter.isTurnOnByBright) variables.changed.bright = true\n      if (variables.startParameter.isTurnOnByTemp) variables.changed.temp = true\n\n      if (!autoChange && isBright && !variables.changed.bright && !variables.smoothOn.active) {\n        variables.changed.bright = true\n      }\n\n      if (!autoChange && isTemp && !variables.changed.temp) {\n        variables.changed.temp = true\n      }\n\n      if (!autoChange && isHue && !variables.changed.hue) {\n        variables.changed.hue = true\n        variables.changed.temp = true\n      }\n\n      if (!autoChange && isSaturation && !variables.changed.sat) {\n        variables.changed.sat = true\n        variables.changed.temp = true\n      }\n    }\n\n    if (isBright && variables.changed.bright) {\n      debug(\"Яркость изменена вручную. Больше меняться автоматически не будет. Значение: {}\", source, isDebug, value, context)\n      variables.runtime.dontChangeBright = true\n    }\n    if (isTemp && variables.changed.temp) {\n      debug(\"Температура изменена вручную. Больше меняться автоматически не будет. Значение: {}\", source, isDebug, value, context)\n      variables.runtime.dontChangeTemp = true\n    }\n    if (isHue && variables.changed.hue) {\n      debug(\"Оттенок изменен вручную. Больше меняться автоматически не будет. Значение: {}\", source, isDebug, value, context)\n      variables.runtime.dontChangeHue = true\n      variables.runtime.dontChangeTemp = true\n    }\n    if (isSaturation && variables.changed.sat && !variables.runtime.dontChangeSat) {\n      debug(\"Насыщенность изменена вручную. Больше меняться автоматически не будет. Значение: {}\", source, isDebug, value, context)\n      variables.runtime.dontChangeSat = true\n      variables.runtime.dontChangeTemp = true\n    }\n\n    if (variables.cronTask && variables.changed.bright && (variables.changed.temp || (variables.changed.hue && variables.changed.sat))) {\n      debug(\"Все параметры, которые могли меняться в циркадном режиме изменены и больше не будут меняться. Останавливаем циркакадный режим\", source, isDebug)\n      stop(source, variables, options)\n      variables.runtime.stopped = true\n      return\n    }\n\n    if (behavior == 1 && variables.cronTask && (variables.changed.bright || variables.changed.temp || variables.changed.hue || variables.changed.sat)) {\n      debug(\"Включено свойство 'Останавливать циркадный режим после изменения любого параметра'. Параметр был изменён, циркадный режим остановлен\", source, isDebug)\n      stop(source, variables, options)\n      variables.runtime.stopped = true\n      return\n    }\n  }\n\n  // Основная логика\n  if (isOn) {\n    if (value) {\n      const brightness = source.getService().getCharacteristic(HC.Brightness);\n      if (brightness == null) {\n        console.error(DEBUG_TITLE + \"Лампочка не умеет изменять яркость\", source, isDebug)\n        return;\n      }\n\n      let enableBrightByWhatChange = options.WhatChange == 0 || options.WhatChange == 1\n      let enableTempByWhatChange = options.WhatChange == 0 || options.WhatChange == 2\n\n      // Начальная установка значения\n      let installStartBright = enableBrightByWhatChange && !variables.startParameter.isTurnOnByBright && !variables.changed.bright && !options.SmoothOn\n      let installStartTemp = enableTempByWhatChange && !variables.startParameter.isTurnOnByTemp && !variables.changed.temp\n      let installStartHue = enableTempByWhatChange && !variables.startParameter.isTurnOnByTemp && !variables.startParameter.isTurnOnByHue && !variables.changed.temp\n      let installStartSat = enableTempByWhatChange && !variables.startParameter.isTurnOnByTemp && !variables.startParameter.isTurnOnBySat && !variables.changed.temp\n\n      if (!installStartBright && !installStartTemp) {\n        debug(\"==== НЕ ЗАПУЩЕН ==== Циркадный режим не запущен, так как при включении лампы были изменены яркость и температура\", source, isDebug)\n        stop(source, variables, options, true)\n        reset(variables)\n        variables.runtime.stopped = true\n        return\n      }\n\n      if (installStartBright || installStartTemp || installStartHue || installStartSat) {\n        variables.lastSetTime = Date.now();\n        let isSet = global.setCircadianLightForService(service, options.Preset, !installStartBright, !installStartTemp, !installStartHue, !installStartSat, options.ChangeTempDelay, isDebug, true);\n        if (!isSet) {\n          stop(source, variables, options)\n          reset(variables)\n          variables.runtime.stopped = true\n        }\n      }\n\n      // Плавное включение\n      let brightAtStart = variables.startParameter.brightAtStart\n      let brightCharacteristic = service.getCharacteristic(HC.Brightness)\n      let smoothTime = options.SmoothOnTime || 0;  // Время плавного включения, по умолчанию 0\n      if (!variables.changed.bright && !variables.startParameter.isTurnOnByBright && enableBrightByWhatChange && smoothTime > 0) {\n        const circadianValue = global.getCircadianLight(options.Preset, service.getUUID())\n        let target = brightAtStart > 0 ? brightAtStart : circadianValue[1]\n        if (target > 1) {\n          variables.smoothOn.active = true;\n          let currentBr = 1;  // Начальная яркость — 1%\n          brightCharacteristic.setValue(currentBr);\n\n          let intervalMs = 100;  // Интервал обновления — 100 мс\n          let steps = (smoothTime * 1000) / intervalMs;  // Количество шагов\n          let increaseBy = (target - currentBr) / steps;  // Шаг увеличения яркости\n\n          let interval = setInterval(function () {\n            if (currentBr >= target || !service.getCharacteristic(HC.On).getValue()) {\n              clearInterval(interval);\n              interval = undefined\n              variables.smoothOn.active = false;\n              if (currentBr >= target) brightCharacteristic.setValue(target);\n            } else {\n              currentBr += increaseBy;\n              currentBr = Math.min(currentBr, target);\n              brightCharacteristic.setValue(Math.round(currentBr));\n            }\n          }, intervalMs);\n          variables.smoothOn.task = interval;\n        }\n      }\n      restartCron(source, variables, options)\n    } else {\n      stop(source, variables, options)\n      reset(variables)\n\n      if (variables.reset.task) {\n        variables.reset.task.clear()\n        variables.reset.task = undefined\n      }\n    }\n  }\n}\n\nfunction setCircadianValue(service, variables, options, fullDebug, linkedCharacteristicType) {\n  var enableBrightByWhatChange = options.WhatChange == 0 || options.WhatChange == 1\n  var enableTempByWhatChange = options.WhatChange == 0 || options.WhatChange == 2\n\n  var dontChangeBright = variables.changed.bright == true || !enableBrightByWhatChange || variables.smoothOn.active\n  var dontChangeTemp = variables.changed.temp == true || !enableTempByWhatChange\n  var dontChangeHue = variables.changed.hue == true || !enableTempByWhatChange\n  var dontChangeSaturate = variables.changed.sat == true || !enableTempByWhatChange\n  if (linkedCharacteristicType) {\n    dontChangeBright = dontChangeBright || linkedCharacteristicType != HC.Brightness\n    dontChangeTemp = dontChangeTemp || linkedCharacteristicType != HC.ColorTemperature\n    dontChangeHue = dontChangeHue || linkedCharacteristicType != HC.Hue\n    dontChangeSaturate = dontChangeSaturate || linkedCharacteristicType != HC.Saturation\n    fullDebug = options.Debug\n  }\n  let isSet = false\n  if (!dontChangeBright || !dontChangeTemp || !dontChangeHue || !dontChangeSaturate) {\n    variables.lastSetTime = Date.now();\n    isSet = global.setCircadianLightForService(service, options.Preset, dontChangeBright, dontChangeTemp, dontChangeHue, dontChangeSaturate, options.ChangeTempDelay, options.Debug, fullDebug);\n  }\n\n  if (!isSet && !linkedCharacteristicType) {\n    stop(service.getCharacteristic(HC.On), variables, options)\n    reset(variables)\n    variables.runtime.stopped = true\n  }\n}\n\nfunction restartCron(source, variables, options) {\n  // Отменяем задачу на обновление\n  if (variables.cronTask && variables.cronTask != undefined) {\n    variables.cronTask.clear()\n  }\n\n  const seconds = (options.RandomSeconds ? Math.floor(Math.random() * 59) : 0) | 0;\n\n  // Запускаем новую задачу на обновление\n  let task = Cron.schedule(seconds + \" */5 * * * *\", function () {\n    const disableName = global.getCircadianLightGlobalVariableForDisable(source.getService())\n    if (GlobalVariables[disableName] == true) {\n      variables.disabled = true\n      stop(source, variables, options)\n      reset(variables)\n    }\n\n    setCircadianValue(source.getService(), variables, options)\n  });\n\n  variables.cronTask = task;\n  debug(\"==== ЗАПУСК ==== Циркадный режим запущен\", source, options.Debug)\n\n  let opts = \"Preset: \" + options.Preset + \". WhatChange: \" + options.WhatChange + \". Behavior: \" + options.Behavior + \". SmoothOnTime: \" + options.SmoothOnTime + \". RandomSeconds: \" + options.RandomSeconds + \". LinkedBehavior: \" + options.LinkedBehavior\n  debug(\"СВОЙСТВА: \" + opts, source, options.Debug)\n}\n\nfunction stop(source, variables, options, dontShowDebug) {\n  // Выключили лампу. Отменяем задачу на циркаду и сбрасываем параметры\n  if (variables.cronTask) {\n    variables.cronTask.clear()\n    variables.cronTask = undefined;\n  }\n  if (dontShowDebug) return\n  debug(\"==== ОСТАНОВКА ==== Циркадный режим остановлен\", source, options.Debug)\n}\n\n// Сбрасываем состояние при выключении\nfunction reset(variables) {\n  if (variables.smoothOn.task != undefined) {\n    variables.smoothOn.task.clear()\n    variables.smoothOn.task = undefined\n  }\n  variables.startParameter.brightAtStart = -1\n  variables.startParameter.isTurnOnByBright = false\n  variables.startParameter.isTurnOnByTemp = false\n  variables.startParameter.isTurnOnByHue = false\n  variables.startParameter.isTurnOnBySat = false\n  variables.smoothOn.active = false\n  variables.changed.bright = false\n  variables.changed.temp = false\n  variables.changed.hue = false\n  variables.changed.sat = false\n  variables.runtime.stopped = false\n  variables.runtime.dontChangeBright = false\n  variables.runtime.dontChangeTemp = false\n  variables.runtime.dontChangeHue = false\n  variables.runtime.dontChangeSat = false\n}\n\nfunction difference(a, b) {\n  return Math.abs(a - b);\n}\n\nfunction contain(source, substring) {\n  return source.toString().indexOf(substring) !== -1\n}\n\nfunction getChageReason(context, uuid) {\n  let changeReason = {\n    auto: false,\n    byLinkedLamp: false,\n    onStart: false,\n    self: false,\n    linkedUUID: undefined,\n  }\n\n  // Разделяем контекст на элементы по символу '<-'\n  const elements = context.toString().split(' <- ')\n  // Проверяем, есть ли элементы в массиве\n  if (elements.length > 0) {\n    let last = elements[elements.length - 1]\n\n    // Условие 0: Последний элемент начинается с 'HUB[OnStart]'\n    if (last.startsWith('HUB[OnStart]')) {\n      changeReason.auto = true\n      changeReason.onStart = true\n    }\n\n    if (last.startsWith('CLINK[')) {\n      changeReason.auto = true\n    }\n\n    // Условие 1: Событие пришло от другого устройства, а далее оно управляет целевым\n    let findCurrent = false\n    elements.forEach((e) => {\n      if (!findCurrent) { if (e.startsWith('C[') && e.startsWith('C[' + uuid)) findCurrent = true }\n      else if (e.startsWith('C[') && !e.startsWith('C[' + uuid)) {\n        let bulbIndex = e.indexOf(\"Lightbulb\")\n        if (bulbIndex > 0) {\n          changeReason.linkedUUID = e.substring(2, bulbIndex - 1)\n          changeReason.byLinkedLamp = true\n        }\n      }\n    })\n\n    // Условие 2: Первые три элемента соответствуют шаблону 'LOGIC <- C <- LOGIC'\n    if (elements.length >= 3 &&\n      elements[0].startsWith('LOGIC') &&\n      elements[1].startsWith('C') &&\n      elements[2] == elements[0]) {\n      changeReason.auto = true\n      changeReason.self = true\n    }\n  }\n  \n  return changeReason;\n}\n\nfunction debug(format, source, isDebug, arg, context) {\n  arg = arg == undefined ? \"\" : arg\n  if (isDebug) {\n    const prefix = DEBUG_TITLE + global.getCircadianLightServiceName(source.getService()) + \" \"\n    const suffix = context ? \". Контекст: {}\" : \"\"\n    console.info(prefix + format + suffix, arg, context)\n  }\n}\n\nconst DEBUG_TITLE = \"Циркадное освещение. \"",
    "type": "LOGIC"
  }
}