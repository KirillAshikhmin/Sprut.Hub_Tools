{
  "scenarioTemplate": {
    "name": "Внешний датчик температуры для термоголовок Aqara E1, SONOFF TRVZB, Danfoss eTRV0101",
    "desc": "Сценарий настраивает термоголовку и привязывает к ней внешний датчик температуры. Поддерживает Aqara E1, SONOFF TRVZB, Danfoss eTRV0101.\nСценарий автоматически определит тип термоголовки и применит соответствующую логику работы.\n\nВАЖНО: Сначала выберите внешний датчик температуры в настройках, затем активируйте сценарий переключателем 'Активно'.",
    "active": true,
    "onStart": true,
    "sync": false,
    "data": "// Константы\nconst DEBUG_TITLE = \"ВДТ: \"; // Константа для отладки\nconst HEATING_STATE = 1; // Состояние нагрева\nconst ONE_DAY_MS = 24 * 60 * 60 * 1000; // Сутки в миллисекундах\nconst HALF_HOUR_MS = 30 * 60 * 1000; // 30 минут в миллисекундах\nconst TEMP_CHANGE_STEP = 0.1; // Шаг изменения температуры в градусах\nconst TEMP_CHANGE_DELAY_MS = 10000; // Задержка перед восстановлением температуры (10 секунд)\n\n// Поддерживаемые термостаты\nconst SUPPORTED_THERMOSTATS = {\n    AQARA_E1: { modelId: \"lumi.airrtc.agl001\", manufacturer: \"Aqara\", name: \"Aqara E1\" },\n    SONOFF_TRVZB: { modelId: \"TRVZB\", manufacturer: \"SONOFF\", name: \"SONOFF TRVZB\" },\n    DANFOSS: { modelId: \"eTRV0101\", manufacturer: \"Danfoss\", name: \"Danfoss eTRV0101\" }\n};\n\n// Получает список названий поддерживаемых термостатов\nfunction getSupportedThermostatsList() {\n    return Object.keys(SUPPORTED_THERMOSTATS).map((key) => SUPPORTED_THERMOSTATS[key].name).join(\", \");\n}\n\n// Выносим название и описание в переменные для использования в info и options\nlet scenarioName = {\n    ru: \"Внешний датчик температуры для термоголовок \" + getSupportedThermostatsList(),\n    en: \"External temperature sensor for thermostats \" + getSupportedThermostatsList()\n};\n\nlet scenarioDescription = {\n    ru: \"Сценарий настраивает термоголовку и привязывает к ней внешний датчик температуры. Поддерживает \" + getSupportedThermostatsList() + \".\\nСценарий автоматически определит тип термоголовки и применит соответствующую логику работы.\\n\\nВАЖНО: Сначала выберите внешний датчик температуры в настройках, затем активируйте сценарий переключателем 'Активно'.\",\n    en: \"Scenario configures the thermostat and binds an external temperature sensor to it. Supports \" + getSupportedThermostatsList() + \".\\nThe scenario will automatically determine the thermostat type and apply the appropriate logic.\\n\\nIMPORTANT: First select the external temperature sensor in the settings, then activate the scenario with the 'Active' switch.\"\n};\n\ninfo = {\n    name: scenarioName.ru,\n    description: scenarioDescription.ru,\n    version: \"2.2\",\n    author: \"@BOOMikru\",\n    onStart: true,\n\n    sourceServices: [HS.Thermostat],\n    sourceCharacteristics: [HC.CurrentHeatingCoolingState],\n\n    options: {\n        desc: {\n            name: { en: \"\", ru: \"\" },\n            desc: scenarioDescription,\n            type: \"String\",\n            value: \"\",\n            formType: \"status\"\n        },\n        sensor: {\n            name: {\n                en: \"Temperature sensor\",\n                ru: \"Датчик температуры\"\n            },\n            desc: {\n                en: \"External temperature sensor\",\n                ru: \"Внешний датчик температуры для привязки\"\n            },\n            type: \"String\",\n            value: \"\",\n            formType: \"list\",\n            values: getServicesByServiceAndCharacteristicType([HS.TemperatureSensor, HS.Thermostat], [HC.CurrentTemperature])\n        },\n        changeTempPeriodically: {\n            name: {\n                en: \"Change temperature value every hour\",\n                ru: \"Менять значения температуры каждый час\"\n            },\n            desc: {\n                en: \"For thermostats not to switch to internal sensor. Changes temperature only if last update was more than 30 minutes ago. (Recommended for Sonoff)\",\n                ru: \"Для того, что бы термоголовка не переключалась на внутренний датчик. Меняет температуру только если последнее обновление было более полу часа назад. (Рекомендуется для Sonoff)\"\n            },\n            type: \"Boolean\",\n            value: false\n        }\n    },\n\n    variables: {\n        lastTemp: undefined,\n        lastUpdateTime: undefined,\n        subscribed: false,\n        subscribe: undefined,\n        tempChangeTask: undefined,\n        tempChangeTimeoutId: undefined,\n        midnightTask: undefined,\n    }\n}\n\nfunction trigger(source, value, variables, options, context) {\n    // Проверяем, запустился ли сценарий при старте хаба\n    const isHubStartup = context && context.toString().indexOf(\"HUB[OnStart]\") >= 0;\n\n    try {\n        let acc = source.getAccessory()\n        let modelId = acc.getModelId()\n        let manufacturer = acc.getManufacturer()\n\n        // Проверка поддержки термостатов\n        let thermostatType = \"\";\n        for (let key in SUPPORTED_THERMOSTATS) {\n            const thermostat = SUPPORTED_THERMOSTATS[key];\n            if (modelId === thermostat.modelId && manufacturer === thermostat.manufacturer) {\n                thermostatType = thermostat.name;\n                break;\n            }\n        }\n\n        if (!thermostatType && !emulate) {\n            logError(`Поддерживаются только термостаты ${getSupportedThermostatsList()}. Текущий: ${manufacturer} ${modelId}`, source, isHubStartup)\n            return;\n        }\n\n        if (options.sensor === \"\") {\n            logError(\"Выберите внешний датчик. Если уже выбрали - активируйте сценарий заново\", source, isHubStartup)\n            return;\n        }\n\n        let externalSwitch = undefined\n        let targetTemperature = undefined\n        let currentHeatingCoolingState = undefined\n\n        // Поиск сервисов в зависимости от типа термостата\n        acc.getServices().forEach(function (service) {\n            if (service.getType() === HS.Switch && !externalSwitch) {\n                externalSwitch = service.getCharacteristic(HC.On)\n            } else if (service.getType() === HS.C_TemperatureControl && !targetTemperature) {\n                targetTemperature = service.getCharacteristic(HC.TargetTemperature)\n            } else if (service.getType() === HS.Thermostat && !currentHeatingCoolingState) {\n                currentHeatingCoolingState = service.getCharacteristic(HC.CurrentHeatingCoolingState)\n            }\n        })\n\n        if (!externalSwitch) {\n            logError(\"Не обнаружен переключатель [Внешний датчик температуры]\", source, isHubStartup)\n            return\n        }\n\n        if (!targetTemperature) {\n            logError(\"Не обнаружен сервис [Температура внешнего датчика]\", source, isHubStartup)\n            return\n        }\n\n        externalSwitch.setValue(true);\n\n        setValueFromSensor(source, variables, options, targetTemperature, isHubStartup);\n        setupSensorSubscription(source, variables, options, targetTemperature, thermostatType, acc, isHubStartup);\n        setupPeriodicTempChange(source, variables, options, targetTemperature, currentHeatingCoolingState);\n    } catch (e) {\n        logError(`Ошибка установки внешнего датчика температуры: ${e.toString()}`, source, isHubStartup)\n    }\n}\n\n// Настраивает подписку на изменения внешнего датчика температуры и создает задачу полуночного обновления\nfunction setupSensorSubscription(source, variables, options, targetTemperature, thermostatType, acc, isHubStartup) {\n    if (!variables.subscribe || !variables.subscribed) {\n        showSubscribeMessage(options.sensor, isHubStartup);\n        let subscribe = Hub.subscribeWithCondition(\"\", \"\", [HS.TemperatureSensor], [HC.CurrentTemperature], function (sensorSource, sensorValue) {\n            let service = sensorSource.getService();\n            let isSelected = service.getUUID() === options.sensor;\n            if (isSelected && targetTemperature) {\n                targetTemperature.setValue(sensorValue);\n                if (variables.lastTemp != sensorValue) {\n                    logInfo(`Значение на термоголовку ${thermostatType} установлено: ${sensorValue}°C`, source, debug);\n                    variables.lastUpdateTime = Date.now();\n                    variables.lastTemp = sensorValue;\n                }\n            }\n        }, acc);\n        variables.subscribe = subscribe;\n        variables.subscribed = true;\n    }\n    if (!variables.midnightTask) {\n        variables.midnightTask = Cron.schedule(\"0 0 0 * * *\", function () {\n            setValueFromSensor(source, variables, options, targetTemperature, false);\n            logInfo(\"Полуночное обновление\", source, debug);\n        });\n    }\n}\n\n// Настраивает периодическое изменение температуры каждый час для предотвращения переключения термоголовки на внутренний датчик\nfunction setupPeriodicTempChange(source, variables, options, targetTemperature, currentHeatingCoolingState) {\n    if (options.changeTempPeriodically) {\n        if (!variables.tempChangeTask) {\n            variables.tempChangeTask = Cron.schedule(\"0 0 * * * *\", function () {\n                // Проверяем, что последнее обновление было более часа назад\n                const currentTime = Date.now();\n                if (variables.lastUpdateTime) {\n                    if (currentTime - variables.lastUpdateTime > ONE_DAY_MS) {\n                        logWarn(\"Периодическое изменение температуры пропущено: нет обновлений от датчика более суток\", source);\n                        return;\n                    }\n                    if (currentTime - variables.lastUpdateTime <= HALF_HOUR_MS) {\n                        logInfo(\"Периодическое изменение температуры пропущено: последнее обновление было менее 30 минут назад\", source, debug);\n                        return;\n                    }\n                }\n\n                // Получаем текущее состояние нагрева из термостата\n                let currentState = currentHeatingCoolingState.getValue();\n                let currentTemp = targetTemperature.getValue();\n\n                // Определяем направление изменения\n                let tempChange = TEMP_CHANGE_STEP;\n                if (currentState === HEATING_STATE) {\n                    // Нагрев - уменьшаем температуру\n                    tempChange = -TEMP_CHANGE_STEP;\n                }\n                // Иначе увеличиваем (tempChange уже TEMP_CHANGE_STEP)\n\n                // Устанавливаем измененное значение\n                let newTemp = currentTemp + tempChange;\n                targetTemperature.setValue(newTemp);\n                logInfo(`Временное изменение температуры: ${newTemp.toFixed(1)}°C (${tempChange > 0 ? '+' : ''}${tempChange}°C)`, source, debug);\n\n                // Через 10 секунд устанавливаем реальное значение\n                // Очищаем предыдущий таймаут, если он еще не выполнился\n                if (variables.tempChangeTimeoutId) {\n                    clearTimeout(variables.tempChangeTimeoutId);\n                }\n                variables.tempChangeTimeoutId = setTimeout(function () {\n                    // Проверяем, что опция все еще включена\n                    if (options.changeTempPeriodically && targetTemperature) {\n                        setValueFromSensor(source, variables, options, targetTemperature, false);\n                    }\n                    variables.tempChangeTimeoutId = undefined;\n                }, TEMP_CHANGE_DELAY_MS);\n            });\n        }\n    } else {\n        // Отключаем задачу, если опция выключена\n        if (variables.tempChangeTask) {\n            variables.tempChangeTask.clear();\n            variables.tempChangeTask = undefined;\n        }\n        // Очищаем активный таймер\n        if (variables.tempChangeTimeoutId) {\n            clearTimeout(variables.tempChangeTimeoutId);\n            variables.tempChangeTimeoutId = undefined;\n        }\n    }\n}\n\n// Парсит идентификатор датчика и возвращает объект с aid и sid\nfunction parseSensorId(sensorId) {\n    const cdata = sensorId.split('.');\n    return {\n        aid: cdata[0],\n        sid: cdata[1]\n    };\n}\n\n// Получает значение температуры из внешнего датчика и устанавливает его на термоголовку с валидацией\nfunction setValueFromSensor(source, variables, options, targetTemperature, isHubStartup) {\n    try {\n        const sensorData = parseSensorId(options.sensor);\n        const aid = sensorData.aid;\n        const sid = sensorData.sid;\n        let sensorAccessory = Hub.getAccessory(aid);\n        if (!sensorAccessory) {\n            logError(`Не найден внешний датчик для термоголовки. ID: ${options.sensor}`, source, isHubStartup);\n            return;\n        }\n        let sensorService = sensorAccessory.getService(sid);\n        if (!sensorService) {\n            logError(`Не найден внешний датчик для термоголовки. ID: ${options.sensor}`, source, isHubStartup);\n            return;\n        }\n\n        // Проверяем статус онлайн перед использованием\n        const infoService = sensorAccessory.getService(HS.AccessoryInformation);\n        if (infoService) {\n            const onlineChar = infoService.getCharacteristic(HC.C_Online);\n            if (!onlineChar || onlineChar.getValue() !== true) {\n                logWarn(`Датчик ${getDeviceName(sensorService)} не в сети`, source);\n            }\n        }\n\n        // Получаем значение температуры\n        const tempChar = sensorService.getCharacteristic(HC.CurrentTemperature);\n        if (!tempChar) {\n            logError(`Характеристика CurrentTemperature не найдена в датчике ${getDeviceName(sensorService)}`, source, isHubStartup);\n            return;\n        }\n\n        let sensorValue = tempChar.getValue();\n\n        // Валидация значения температуры\n        if (sensorValue === null || sensorValue === undefined || isNaN(sensorValue)) {\n            logError(`Невалидное значение температуры от датчика ${getDeviceName(sensorService)}: ${sensorValue}`, source, isHubStartup);\n            return;\n        }\n\n        // Проверка на разумные пределы (-50 до 100 градусов)\n        if (sensorValue < -50 || sensorValue > 100) {\n            logWarn(`Подозрительное значение температуры от датчика ${getDeviceName(sensorService)}: ${sensorValue}°C`, source);\n        }\n\n        targetTemperature.setValue(sensorValue);\n        logInfo(`Значение на термоголовку установлено: ${sensorValue}°C`, source, debug);\n        if (variables.lastTemp !== sensorValue) {\n            variables.lastTemp = sensorValue;\n            variables.lastUpdateTime = Date.now();\n        }\n\n        // Проверка на сутки без обновлений\n        const currentTime = Date.now();\n        if (variables.lastUpdateTime && (currentTime - variables.lastUpdateTime > ONE_DAY_MS)) {\n            logError(`Нет показаний от внешнего датчика (${getDeviceName(sensorService)}) в течении суток или более`, source, isHubStartup);\n            return;\n        }\n    } catch (e) {\n        logError(`Не удалось получить температуру с датчика ${options.sensor}: ${e.toString()}`, source, isHubStartup);\n    }\n}\n\nfunction showSubscribeMessage(sensor, isHubStartup) {\n    try {\n        const sensorData = parseSensorId(sensor);\n        const aid = sensorData.aid;\n        const sid = sensorData.sid;\n        const acc = Hub.getAccessory(aid);\n        if (!acc) {\n            console.warn(`Не удалось найти аксессуар для датчика: ${aid}`);\n            return;\n        }\n        const service = acc.getService(sid);\n        if (!service) {\n            console.warn(`Не удалось найти сервис для датчика: ${sid}`);\n            return;\n        }\n        const accName = service.getAccessory().getName();\n        const sName = service.getName();\n        const displayName = accName === sName ? accName : accName + \" \" + sName;\n        if (isHubStartup) {\n            console.info(`Подключен внешний датчик: ${displayName}`);\n        } else {\n            console.message(`Подключен внешний датчик: ${displayName}`);\n        }\n    } catch (e) {\n        console.warn(`Ошибка при отображении сообщения о подписке: ${e.toString()}`);\n    }\n}\n\n// Вспомогательные функции\nfunction getDeviceName(service) {\n    const acc = service.getAccessory();\n    const room = acc.getRoom().getName();\n    const accName = acc.getName();\n    const sName = service.getName();\n    const name = room + \" -> \" + (accName === sName ? accName : accName + \" \" + sName) + \" (\" + service.getUUID() + \")\" + (!service.isVisible() ? \". Скрытый\" : \"\");\n    return name;\n}\n\nfunction logInfo(text, source, show) {\n    if (show) console.info(getLogText(text, source));\n}\nfunction logWarn(text, source) {\n    console.warn(getLogText(text, source));\n}\nfunction logError(text, source, isHubStartup) {\n    if (isHubStartup) {\n        logWarn(text, source)\n    } else {\n        console.error(getLogText(text, source))\n    }\n}\n\nfunction getLogText(text, source) {\n    try {\n        return `${text} | ${DEBUG_TITLE} ${getDeviceName(source.getService())}`\n    } catch (e) {\n        return `${text} | ${DEBUG_TITLE}`\n    }\n}\n\nfunction getServicesByServiceAndCharacteristicType(serviceTypes, characteristicTypes) {\n    let unsortedServicesList = [];\n    Hub.getAccessories().forEach((a) => {\n        a.getServices()\n            .filter((s) => serviceTypes.indexOf(s.getType()) >= 0)\n            .filter((s) => characteristicTypes.some((c) => s.getCharacteristic(c)))\n            .forEach((s) => {\n                let name = getDeviceName(s);\n                unsortedServicesList.push({\n                    name: { ru: name, en: name },\n                    value: s.getUUID()\n                });\n            });\n    });\n    let sortedServicesList = [{ name: { ru: \"Не выбрано\", en: \"Not selected\" }, value: '' }];\n    unsortedServicesList.sort((a, b) => a.name.ru.localeCompare(b.name.ru)).forEach((s) => sortedServicesList.push(s));\n    return sortedServicesList;\n}\n\n//Эмуляция работы на виртуальном термостате. Устанавливает текущую температуру\nlet emulate = false\n\n// Вывод в лог информационные сообщения о работе сценария\nlet debug = true",
    "type": "LOGIC"
  }
}