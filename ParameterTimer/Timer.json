{
  "scenarioTemplate": {
    "name": "⏰ Параметр-Таймер",
    "desc": "Автоматически отключает Boolean параметр через заданное количество секунд из Integer параметра.\n\nПринцип работы:\n• При включении Boolean (true) запускается таймер на время из Integer\n• При изменении Integer во время работы - таймер перезапускается\n• При изменении Boolean во время работы - таймер останавливается или перезапускается\n• По истечении времени Boolean автоматически отключается (false)",
    "active": true,
    "onStart": true,
    "sync": false,
    "data": "// Выносим название и описание в переменные для использования в info и options\nlet scenarioName = {\n    ru: \"⏰ Параметр-Таймер\",\n    en: \"⏰ Parameter Timer\"\n};\n\nlet scenarioDescription = {\n    ru: \"Автоматически отключает Boolean параметр через заданное количество секунд из Integer параметра.\\n\\nПринцип работы:\\n• При включении Boolean (true) запускается таймер на время из Integer\\n• При изменении Integer во время работы - таймер перезапускается\\n• При изменении Boolean во время работы - таймер останавливается или перезапускается\\n• По истечении времени Boolean автоматически отключается (false)\",\n    en: \"Automatically turns off Boolean parameter after specified number of seconds from Integer parameter.\\n\\nHow it works:\\n• When Boolean is turned on (true), timer starts for Integer seconds\\n• When Integer changes during operation - timer restarts\\n• When Boolean changes during operation - timer stops or restarts\\n• After timeout Boolean automatically turns off (false)\"\n};\n\n/*\n * info - Обязательное поле, описывающее сценарий.\n * Считывается хабом в момент загрузки или сохранения сценария.\n * В коде обращаться к этому объекту запрещено, считать данные с него тоже не получится.\n * Необходимо использовать только значения, которые приходят в функции compute или trigger.\n */\ninfo = { \n  name: scenarioName.ru,\n  description: scenarioDescription.ru,\n  version: \"1.0\",\n  author: \"@BOOMikru\",\n  sourceServices: [HS.C_Option],\n  sourceCharacteristics: [HC.C_Boolean, HC.C_Integer],\n\n  options: {\n    desc: {\n      name: {en: \"\", ru: \"\"}, \n      desc: scenarioDescription,\n      type: \"String\",\n      value: \"\",\n      formType: \"status\"\n    },\n    countdownDisplay: {\n      name: {\n        en: \"Display countdown\",\n        ru: \"Отображать отсчёт\"\n      },\n      desc: {\n        en: \"Choose how to display remaining time countdown\",\n        ru: \"Выберите способ отображения оставшегося времени\"\n      },\n      type: \"Integer\",\n      value: 0, // 0 - Нет, 1 - Целое значение, 2 - Дробное значение\n      formType: \"list\",\n      values: [\n        { value: 0, name: { ru: \"Нет\", en: \"No\" } },\n        { value: 1, name: { ru: \"В Целом значении\", en: \"In Integer value\" } },\n        { value: 2, name: { ru: \"В Дробном значении\", en: \"In Double value\" } }\n      ]\n    },\n    changeServiceName: {\n      name: {\n        en: \"Change service name\",\n        ru: \"Менять имя сервиса\"\n      },\n      desc: {\n        en: \"Show countdown in service name when timer is active\",\n        ru: \"Показывать обратный отсчёт в имени сервиса при активном таймере\"\n      },\n      type: \"Boolean\",\n      value: false\n    }\n  },\n\n  variables: {\n    activeTimer: undefined, // ID активный таймер\n    isTimerRunning: false, // Флаг работы таймера\n    countdownInterval: undefined, // ID интервала обновления отсчёта\n    originalIntegerValue: undefined, // Исходное значение Integer параметра\n    originalServiceName: undefined, // Исходное имя сервиса\n  }\n}\n\nfunction trigger(source, value, variables, options, context) {\n  // Проверяем, не изменили ли мы характеристику сами\n  if (isSelfChanged(context)) {\n    return;\n  }\n  \n  let service = source.getService();\n  let characteristicType = source.getType();\n  \n  // Получаем характеристики один раз и кэшируем\n  let booleanChar = service.getCharacteristic(HC.C_Boolean);\n  let integerChar = service.getCharacteristic(HC.C_Integer);\n  \n  if (!booleanChar || !integerChar) {\n    console.error(\"В сервисе не найдены необходимые характеристики C_Boolean и C_Integer\");\n    return;\n  }\n  \n  // Останавливаем текущий таймер и интервал отсчёта, если они запущены\n  stopTimerAndCountdown(variables);\n  \n  // Проверяем какая характеристика изменилась и выполняем соответствующие действия\n  if (characteristicType === HC.C_Boolean) {\n    if (value === true) {\n      // Boolean включен - запускаем таймер если Integer > 0\n      let integerValue = integerChar.getValue();\n      if (integerValue > 0) {\n        // Сохраняем исходное значение Integer, если оно еще не сохранено\n        if (variables.originalIntegerValue === undefined) {\n          variables.originalIntegerValue = integerValue;\n        }\n        // Обновляем имя сервиса с обратным отсчётом\n        updateServiceName(service, true, variables, options, integerValue);\n        startTimer(booleanChar, integerValue, variables, options, service);\n      }\n    } else {\n      // Boolean отключен - восстанавливаем исходные значения\n      restoreOriginalValues(variables, integerChar, service, options);\n      // Восстанавливаем исходное имя сервиса\n      restoreServiceName(service, variables, options);\n    }\n    \n  } else if (characteristicType === HC.C_Integer) {\n    // Всегда сохраняем исходное значение Integer при его изменении\n    variables.originalIntegerValue = value;\n    \n    let booleanValue = booleanChar.getValue();\n    if (booleanValue === true && value > 0) {\n      // Boolean включен и новое значение Integer > 0 - перезапускаем таймер\n      startTimer(booleanChar, value, variables, options, service);\n    }\n  }\n}\n\n/**\n * Проверяет, изменилась ли характеристика самим сценарием\n * @param {Object} context - Контекст изменения характеристики\n * @returns {boolean} true если изменение было сделано сценарием\n */\nfunction isSelfChanged(context) {\n    let selfChanged = false;\n    const elements = context.toString().split(' <- ');\n    if (elements.length >= 3 &&\n        elements[0].startsWith('LOGIC') &&\n        elements[1].startsWith('C') &&\n        elements[2] == elements[0]) {\n      selfChanged = true;\n    }\n    return selfChanged;\n  }\n\n/**\n * Сохраняет исходное имя сервиса\n * @param {Service} service - Сервис\n * @param {Object} variables - Переменные сценария\n */\nfunction saveOriginalServiceName(service, variables) {\n  if (variables.originalServiceName === undefined) {\n    variables.originalServiceName = service.getName();\n  }\n}\n\n/**\n * Обновляет имя сервиса с префиксом состояния\n * @param {Service} service - Сервис\n * @param {boolean} isActive - Активен ли таймер\n * @param {Object} variables - Переменные сценария\n * @param {Object} options - Опции сценария\n * @param {number} remainingSeconds - Оставшиеся секунды (опционально)\n */\nfunction updateServiceName(service, isActive, variables, options, remainingSeconds) {\n  if (!options.changeServiceName) {\n    return;\n  }\n  \n  saveOriginalServiceName(service, variables);\n  \n  if (isActive && remainingSeconds !== undefined) {\n    // При активном таймере показываем обратный отсчёт\n    let newName = remainingSeconds + \" - \" + variables.originalServiceName;\n    service.setName(newName);\n  } else {\n    // При выключенном таймере показываем исходное имя\n    service.setName(variables.originalServiceName);\n  }\n}\n\n/**\n * Восстанавливает исходное имя сервиса\n * @param {Service} service - Сервис\n * @param {Object} variables - Переменные сценария\n * @param {Object} options - Опции сценария\n */\nfunction restoreServiceName(service, variables, options) {\n  if (!options.changeServiceName || variables.originalServiceName === undefined) {\n    return;\n  }\n  \n  service.setName(variables.originalServiceName);\n  variables.originalServiceName = undefined;\n}\n\n/**\n * Останавливает таймер и интервал отсчёта\n * @param {Object} variables - Переменные сценария\n */\nfunction stopTimerAndCountdown(variables) {\n  if (variables.activeTimer) {\n    clearTimeout(variables.activeTimer);\n    variables.activeTimer = undefined;\n    variables.isTimerRunning = false;\n  }\n  \n  if (variables.countdownInterval) {\n    clearInterval(variables.countdownInterval);\n    variables.countdownInterval = undefined;\n  }\n}\n\n/**\n * Восстанавливает исходные значения характеристик\n * @param {Object} variables - Переменные сценария\n * @param {Characteristic} integerChar - Integer характеристика\n * @param {Service} service - Сервис\n */\nfunction restoreOriginalValues(variables, integerChar, service, options) {\n  // Восстанавливаем исходное значение Integer\n  if (variables.originalIntegerValue !== undefined) {\n    integerChar.setValue(variables.originalIntegerValue);\n    variables.originalIntegerValue = undefined;\n  }\n  \n  // Устанавливаем Double в 0 только если используется отображение в Double\n  if (options && options.countdownDisplay === 2) {\n    let doubleChar = service.getCharacteristic(HC.C_Double);\n    if (doubleChar) {\n      doubleChar.setValue(0);\n    }\n  }\n}\n\n/**\n * Функция запуска таймера\n * @param {Characteristic} booleanChar - Boolean характеристика для отключения\n * @param {number} seconds - Количество секунд до отключения\n * @param {Object} variables - Переменные сценария\n * @param {Object} options - Опции сценария\n * @param {Service} service - Сервис\n */\nfunction startTimer(booleanChar, seconds, variables, options, service) {\n  // Проверяем корректность значения\n  if (typeof seconds !== 'number' || seconds <= 0 || !isFinite(seconds) || seconds > 86400) {\n    console.error(`Параметр-Таймер: некорректное значение времени: ${seconds} (допустимо: 1-86400 секунд)`);\n    return;\n  }\n  \n  variables.isTimerRunning = true;\n  \n  // Получаем характеристики один раз для оптимизации\n  let integerChar = service.getCharacteristic(HC.C_Integer);\n  let doubleChar = options.countdownDisplay === 2 ? service.getCharacteristic(HC.C_Double) : null;\n  \n  // Запускаем интервал отсчёта, если включен\n  if (options.countdownDisplay > 0) {\n    let remainingSeconds = seconds;\n    let lastDisplayValue = -1; // Для предотвращения лишних обновлений\n    \n    // Сразу обновляем отображение при запуске таймера\n    if (options.countdownDisplay === 1 && integerChar) {\n      integerChar.setValue(remainingSeconds);\n    } else if (options.countdownDisplay === 2 && doubleChar) {\n      doubleChar.setValue(remainingSeconds);\n    }\n    lastDisplayValue = remainingSeconds;\n    \n    variables.countdownInterval = setInterval(function() {\n      remainingSeconds--;\n      \n      // Обновляем отображение только при изменении значения\n      if (remainingSeconds !== lastDisplayValue) {\n        if (options.countdownDisplay === 1 && integerChar) {\n          integerChar.setValue(remainingSeconds);\n        } else if (options.countdownDisplay === 2 && doubleChar) {\n          doubleChar.setValue(remainingSeconds);\n        }\n        \n        // Обновляем имя сервиса с обратным отсчётом только если время > 0\n        if (remainingSeconds > 0) {\n          updateServiceName(service, true, variables, options, remainingSeconds);\n        }\n        \n        lastDisplayValue = remainingSeconds;\n      }\n      \n      if (remainingSeconds <= 0) {\n        clearInterval(variables.countdownInterval);\n        variables.countdownInterval = undefined;\n      }\n    }, 1000);\n  }\n  \n  // Создаем таймер\n  variables.activeTimer = setTimeout(function() {\n    // Отключаем Boolean параметр\n    booleanChar.setValue(false);\n    \n    // Восстанавливаем исходные значения\n    restoreOriginalValues(variables, integerChar, service, options);\n    \n    // Восстанавливаем исходное имя сервиса\n    restoreServiceName(service, variables, options);\n    \n    // Очищаем переменные\n    variables.activeTimer = undefined;\n    variables.isTimerRunning = false;\n    \n  }, seconds * 1000);\n}\n\n",
    "type": "LOGIC"
  }
}
