{
  "scenarioTemplate": {
    "name": "Пошаговое изменение характеристики по кнопке или датчику касания",
    "desc": "Изменяет выбранную характеристику устройства по нажатию на кнопку или в цикле, пока кнопка зажата",
    "active": true,
    "onStart": false,
    "sync": false,
    "data": "let characteristicsList = [];\nlet servicesList = [];\n\ninfo = {\n    name: \"Пошаговое изменение характеристики по кнопке или датчику касания\",\n    description: \"Изменяет выбранную характеристику устройства по нажатию на кнопку или в цикле, пока кнопка зажата\",\n    version: \"1.0\",\n    author: \"@BOOMikru Special thx to @dshtolin\",\n    onStart: false,\n\n    sourceServices: [HS.ContactSensor, HS.StatelessProgrammableSwitch],\n    sourceCharacteristics: [HC.ContactSensorState, HC.ProgrammableSwitchEvent],\n\n    options: {\n        step: {\n            name: {\n                en: \"Step\",\n                ru: \"Шаг изменения\"\n            },\n            type: \"Double\", // Изменено на Integer\n            value: 10 // Значение по умолчанию для шага\n        },\n        intervalTime: {\n            name: {\n                en: \"Interval Time (milliseconds)\",\n                ru: \"Время интервала (миллисекунды)\"\n            },\n            desc: {\n                en: \"For contact sensor\",\n                ru: \"Для датчика касания\"\n            },\n            type: \"Integer\", // Изменено на Integer\n            value: 500 // Значение по умолчанию для времени интервала\n        },\n        delay: {\n            name: {\n                en: \"Delay Time (milliseconds)\",\n                ru: \"Время задержки перед изменением (миллисекунды)\"\n            },\n            desc: {\n                en: \"For contact sensor\",\n                ru: \"Для датчика касания\"\n            },\n            type: \"Integer\", // Изменено на Integer\n            value: 500 // Значение по умолчанию для времени интервала\n        },\n        whatChange: {\n            name: {\n                en: \"What сhange\",\n                ru: \"Что изменять\"\n            },\n            type: \"Integer\",\n            value: -1,\n            formType: \"list\",\n            values: characteristicsList\n        },\n        characteristic: {\n            name: {\n                en: \"Characteristic\",\n                ru: \"Выберите устройство\"\n            },\n            type: \"String\",\n            value: \"\",\n            formType: \"list\",\n            values: servicesList\n        },\n        accessoryId: {\n            name: {\n                en: \"Characteristic\",\n                ru: \"   или укажите ID аксессуара\"\n            },\n            type: \"Integer\",\n            value: 0,\n        },\n        serviceId: {\n            name: {\n                en: \"Characteristic\",\n                ru: \"   и ID сервиса\"\n            },\n            type: \"Integer\",\n            value: 0,\n        },\n        direction: {\n            name: {\n                en: \"Change direction\",\n                ru: \"Направление изменения\"\n            },\n            type: \"Integer\",\n            value: 0,\n            formType: \"list\",\n            values: [\n                { value: 0, name: { en: \"Increase and decrease\", ru: \"Увеличивать и уменьшать\" } },\n                { value: 1, name: { en: \"Increase\", ru: \"Увеличивать\" } },\n                { value: 2, name: { en: \"Decrease\", ru: \"Уменьшать\" } }\n            ]\n        },\n        zero: {\n            name: {\n                en: \"To zero\",\n                ru: \"Не уменьшать до 0\"\n            },\n            desc: {\n                en: \"For some characrestics zero value equal to turn off\",\n                ru: \"В некоторых характеристиках значение 0 приводит к выключению устройства (напр. яркость у ламп). Данная настройка ставит минимальное значение 1, то есть не до полного отключения.\"\n            },\n            type: \"Boolean\", // Изменено на Integer\n            value: true // Значение по умолчанию для времени интервала\n        },\n        customLimits: {\n            name: {\n                en: \"Custom limits\",\n                ru: \"Собственные ограничения\"\n            },\n            desc: {\n                en: \"example: 18-24 for temperature\",\n                ru: \"Например установить от 18 до 24 градусов при изменении температуры\"\n            },\n            type: \"Boolean\", // Изменено на Integer\n            value: false // Значение по умолчанию для времени интервала\n        },\n        min: {\n            name: {\n                en: \"minimum\",\n                ru: \"   ↓ минимальное значение\"\n            },\n            type: \"Double\",\n            value: 0,\n        },\n        max: {\n            name: {\n                en: \"maximum\",\n                ru: \"   ↑ максимальное значение\"\n            },\n            type: \"Double\",\n            value: 0,\n        },\n        customSteps: {\n            name: {\n                en: \"Custom steps\",\n                ru: \"Собственные шаги\"\n            },\n            desc: {\n                en: \"example: 1;7;16;35\",\n                ru: \"Через точку с запятой. Например: 1;7;16;35. Можно вводить дробные значения через точку (25.5). Если установлено - шастройка 'Шаг' не используется\"\n            },\n            type: \"String\",\n            value: \"\",\n        },\n        notification: {\n            name: {\n                en: \"Send notification\",\n                ru: \"Отправлять уведомление\"\n            },\n            desc: {\n                en: \"System and to telegram\",\n                ru: \"Cистемные уведомления и в telegram\"\n            },\n            type: \"Boolean\", // Изменено на Integer\n            value: false // Значение по умолчанию для времени интервала\n        },\n    },\n\n    variables: {\n        delayTimer: undefined,\n        interval: undefined,\n        increseDirection: undefined\n    }\n};\n\nfunction trigger(source, value, variables, options) {\n    try {\n        if (options.whatChange < 0) {\n            log.error(\"Необходимо выбрать характеристику для изменения\");\n            return;\n        }\n        if (options.characteristic === '' && (options.accessoryId <= 0 || options.serviceId <= 0)) {\n            log.error(\"Необходимо выбрать аксессуар для изменения яркости через виртуальную логику\");\n            return;\n        }\n        var service\n        if (options.characteristic != '') {\n            const cdata = options.characteristic.split('.');\n            const aid = cdata[0];\n            const sid = cdata[1];\n            service = Hub.getAccessory(aid).getService(sid)\n            if (service == null) {\n                log.error(\"Выбранное устройство не найдено\");\n                return;\n            }\n        } else {\n            let accessory = Hub.getAccessory(options.accessoryId)\n            if (accessory == null) {\n                log.error(\"Введённое устройство не найдено\");\n                return;\n            }\n            service = accessory.getService(options.serviceId)\n            if (service == null) {\n                log.error(\"Введённый сервис не найден у аксессуара {} {}\", accessory.getName(), accessory.getUUID());\n                return;\n            }\n        }\n\n        const characteristic = getCharacteristicByValue(options.whatChange)\n        if (!characteristic) {\n            log.error(\"Выбранная характеристика не найдена\");\n            return;\n        }\n        const characteristicType = characteristic.type\n        const serviceCharacteristic = service.getCharacteristic(characteristicType);\n        if (!serviceCharacteristic) {\n            log.error(\"Характеристика {} не найдена у {}\", characteristicType, getDeviceName(service));\n            return;\n        }\n\n        let defaultMin = characteristic.min\n        let defaultMax = characteristic.max\n        const notification = options.notification\n        const step = options.step\n        const intervalTime = options.intervalTime\n        const delay = options.delay\n        const direction = options.direction\n        const zero = options.zero\n        const customLimits = options.customLimits\n        const min = options.min\n        const max = options.max\n        const customSteps = parseCustomSteps(options.customSteps)\n        if (options.customSteps != '') {\n            if (customSteps == null) {\n                log.error(\"неверно указаны собственные шаги. Убедитесь что введено более 2 значений через точку с запятой. Текущее значение: {}\", options.customSteps);\n                return;\n            }\n            defaultMin = customSteps[0]\n            defaultMax = customSteps[customSteps.length - 1]\n        }\n\n        const characteristicMin = customLimits ? Math.max(defaultMin, min) : (defaultMin == 0 && zero ? 1 : defaultMin)\n        const characteristicMax = customLimits ? Math.min(defaultMax, max) : defaultMax\n\n        const middleValue = (characteristicMax - characteristicMin) / 2\n\n        if (variables.interval) {\n            clearInterval(variables.interval);\n            variables.interval = undefined;\n        }\n        if (variables.delayTimer) {\n            clearInterval(variables.delayTimer);\n            variables.delayTimer = undefined;\n        }\n\n        const isButton = source.getType() == HC.ProgrammableSwitchEvent\n\n        // Одиночное нажатие кнопки\n        if (isButton && value == 0) {\n            let currentValue = serviceCharacteristic.getValue();\n            var increase = getIsIncrease(direction, currentValue, middleValue, variables)\n            let nextValue = getNextValue(currentValue, characteristicMin, characteristicMax, step, customSteps, increase)\n            setValueAndSendNotify(serviceCharacteristic, characteristic, nextValue.value, notification)\n            if (nextValue.isLimit) {\n                variables.increseDirection = !increase\n            }\n        } else {\n            // Датчик касания открыт\n            if (value === 1) {\n                variables.delayTimer = setTimeout(function () {\n                    variables.delayTimer = undefined\n                    var currentValue = serviceCharacteristic.getValue();\n                    var increase = getIsIncrease(direction, currentValue, middleValue, variables)\n                    variables.interval = setInterval(function () {\n                        let nextValue = getNextValue(serviceCharacteristic.getValue(), characteristicMin, characteristicMax, step, customSteps, increase)\n                        setValueAndSendNotify(serviceCharacteristic, characteristic, nextValue.value, notification)\n                        // Останавливаем интервал, если значение достигло предела (0 или 100)\n                        if (nextValue.isLimit) {\n                            variables.increseDirection = !increase\n                            clearInterval(variables.interval);\n                            variables.interval = undefined;\n                        }\n                    }, intervalTime); // Используем время интервала из options\n                }, delay)\n            }\n        }\n    } catch (e) {\n        log.error(\"Ошибка выполнения задачи: \" + e.message);\n    }\n}\n\nfunction setValueAndSendNotify(serviceCharacteristic, characteristic, value, notification) {\n    serviceCharacteristic.setValue(value)\n    if (notification) {\n        const text = \"Установлено: \" + characteristic.name.ru + \" у \" + getDeviceName(serviceCharacteristic.getService())\n        Notify.text(value + \" \" + text).send()\n        if (global.sendToTelegram !== undefined)\n            global.sendToTelegram([\"*\"+value+\"*\", text]);\n    }\n}\n\nfunction parseCustomSteps(customSteps) {\n    if (customSteps === '') return null\n    let itemsStr = customSteps.trim().replace(\" \", \"\").replace(\",\", \".\").split(\";\")\n    let items = []\n    itemsStr.forEach(function (i) { let value = parseFloat(i); if (!isNaN(value)) items.push(value) })\n    if (itemsStr.length <= 1) return null\n    let sorted = items.sort(function (a, b) { return a - b; })\n    return sorted\n}\n\nfunction getNextValue(current, min, max, step, customSteps, increase) {\n    var newValue\n\n    if (customSteps != null) {\n        newValue = fromCustomSteps(current, customSteps, increase)\n    } else {\n        if (increase) {\n            newValue = current + step, max;\n        } else {\n            newValue = current - step, min;\n        }\n    }\n    newValue = Math.min(Math.max(newValue, min), max);\n    let isLimit = (!increase && newValue === min) || (increase && newValue === max)\n    return { value: newValue, isLimit: isLimit }\n}\n\nfunction bisectLeft(arr, value) {\n    let lo = 0, hi = arr.length;\n    while (lo < hi) {\n        const mid = (lo + hi) >> 1;\n        if (arr[mid] < value) {\n            lo = mid + 1;\n        } else {\n            hi = mid;\n        }\n    }\n    return lo;\n}\n\nfunction fromCustomSteps(current, customSteps, increase) {\n    if (customSteps.length === 0) return null;\n    const index = bisectLeft(customSteps, current);\n    // Случай, когда элемент найден в массиве\n    if (index < customSteps.length && customSteps[index] === current) {\n        if (increase) {\n            return (index + 1 < customSteps.length) ? customSteps[index + 1] : customSteps[index];\n        } else {\n            return (index - 1 >= 0) ? customSteps[index - 1] : customSteps[index];\n        }\n    }\n    // Элемент не найден\n    else {\n        if (increase) {\n            return ((index + 1) < customSteps.length) ? customSteps[index + 1] : customSteps[customSteps.length - 1];\n        } else {\n            return (index > 0) ? customSteps[index - 1] : customSteps[0];\n        }\n    }\n}\n\nfunction getIsIncrease(direction, currentValue, middleValue, variables) {\n    let increase\n    if (direction == 1) {\n        increase = true\n    } else if (direction == 2) {\n        increase = false\n    } else {\n        if (variables.increseDirection === true) increase = true\n        else if (variables.increseDirection === false) increase = false\n        else {\n            increase = direction == 0 ? (currentValue < middleValue) : (direction == 1 ? true : false)\n            variables.increseDirection = increase\n        }\n    }\n    return increase\n}\n\nfunction getCharacteristicByValue(value) {\n    var target\n    characteristicsList.forEach(function (c) {\n        if (c.value == value) {\n            target = c\n            return target\n        }\n    })\n    return target\n}\n\nfunction getDeviceName(service) {\n    const acc = service.getAccessory();\n    const room = acc.getRoom().getName()\n    const accName = service.getAccessory().getName()\n    const sName = service.getName()\n    const name = room + \" -> \" + (accName == sName ? accName : accName + \" \" + sName) + \" (\" + service.getUUID() + \")\"\n    return name\n}\n\n// тип сервиса и его тип характеристики, значение которой будем менять\ncharacteristicsList.push({ name: { ru: \"Не выбрано\", en: \"Not selected\", en: \"\" }, value: -1 });\ncharacteristicsList.push({ name: { ru: \"Яркость\", en: \"\" }, value: 0, type: HC.Brightness, min = 0, max = 100 });\ncharacteristicsList.push({ name: { ru: \"Цветовая температура\", en: \"\" }, value: 1, type: HC.ColorTemperature, min = 50, max = 400 });\ncharacteristicsList.push({ name: { ru: \"Насыщенность\", en: \"\" }, value: 2, type: HC.Saturation, min = 0, max = 100 });\ncharacteristicsList.push({ name: { ru: \"Оттенок\", en: \"\" }, value: 3, type: HC.Hue, min = 0, max = 360 });\ncharacteristicsList.push({ name: { ru: \"Целевая позиция\", en: \"\" }, value: 4, type: HC.TargetPosition, min = 0, max = 100 });\ncharacteristicsList.push({ name: { ru: \"Целевая температура\", en: \"\" }, value: 5, type: HC.TargetTemperature, min = 0, max = 100 });\ncharacteristicsList.push({ name: { ru: \"Целевая влажность\", en: \"\" }, value: 6, type: HC.TargetRelativeHumidity, min = 0, max = 100 });\ncharacteristicsList.push({ name: { ru: \"Порог нагрева\", en: \"\" }, value: 7, type: HC.HeatingThresholdTemperature, min = 0, max = 100 });\ncharacteristicsList.push({ name: { ru: \"Порог охлаждения\", en: \"\" }, value: 8, type: HC.CoolingThresholdTemperature, min = 0, max = 100 });\ncharacteristicsList.push({ name: { ru: \"Скорость вентилятора (%)\", en: \"\" }, value: 9, type: HC.RotationSpeed, min = 0, max = 100 });\ncharacteristicsList.push({ name: { ru: \"Скорость вентилятора (Шаг)\", en: \"\" }, value: 10, type: HC.C_FanSpeed, min = 0, max = 5 });\ncharacteristicsList.push({ name: { ru: \"Громкость\", en: \"\" }, value: 11, type: HC.Volume, min = 0, max = 100 });\n\nlet characteriscticsToFound = [];\ncharacteristicsList.forEach(function (c) {\n    characteriscticsToFound.push(c.type)\n})\n\nlet servicesListUnsort = [];\nservicesList.push({ name: { ru: \"Не выбрано\", en: \"Not selected\", en: \"\" }, value: '' });\n// подготовка списка характеристик для выбора в настройке логики\nvar found = false\nHub.getAccessories().forEach(function (a) {\n    a.getServices().forEach(function (s) {\n        found = false\n        s.getCharacteristics().forEach(function (c) {\n            if (found == true || characteriscticsToFound.indexOf(c.getType()) < 0) return;\n\n            const displayname = getDeviceName(s);\n            servicesListUnsort.push({\n                name: { ru: displayname, en: displayname },\n                value: s.getUUID()\n            });\n            found = true\n        })\n    })\n});\nservicesListUnsort.sort(function (a, b) { return a.name.ru.localeCompare(b.name.ru); }).forEach(function (s) { servicesList.push(s) })\n",
    "type": "LOGIC"
  }
}