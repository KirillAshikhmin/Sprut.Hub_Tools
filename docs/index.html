tdown 2<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sprut.hub. Шаблоны. Редактор и валидатор</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.7/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.7/addon/fold/foldgutter.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.7/theme/dracula.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.7/addon/hint/show-hint.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.7/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.7/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.7/addon/fold/foldcode.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.7/addon/fold/foldgutter.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.7/addon/fold/brace-fold.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ajv/6.12.6/ajv.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.7/addon/hint/show-hint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.7/addon/hint/json-hint.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0 40px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            transition: background-color 0.3s, color 0.3s;
        }
        body.light {
            background-color: #f0f0f0;
            color: #000;
        }
        body.dark {
            background-color: #1e1e1e;
            color: #fff;
        }
        .container {
            max-width: 100%;
            margin: 20px auto;
            flex: 1;
        }
        .header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .header-row h1 {
            margin: 0;
            font-size: 24px;
        }
        .theme-toggle {
            margin-left: 20px;
        }
        #themeSelect {
            padding: 8px;
            font-size: 16px;
            border-radius: 4px;
            border: 1px solid #ccc;
            background-color: #fff;
            cursor: pointer;
        }
        body.dark #themeSelect {
            background-color: #333;
            border-color: #555;
            color: #fff;
        }
        .editor-container {
            border: 1px solid #ccc;
            margin-bottom: 10px;
            width: 100%;
            box-sizing: border-box;
        }
        body.dark .editor-container {
            border-color: #444;
        }
        .CodeMirror {
            height: 70vh !important;
            width: 100% !important;
            box-sizing: border-box;
        }
        .button-row-top, .button-row-bottom {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            flex-wrap: wrap;
            gap: 10px;
        }
        .left-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .right-buttons {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 10px;
        }
        button {
            padding: 10px 20px;
            cursor: pointer;
            font-size: 16px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #fff;
        }
        body.dark button {
            background-color: #333;
            border-color: #555;
            color: #fff;
        }
        #errorOutput, #correctionOutput {
            margin-top: 10px;
            white-space: pre-wrap;
        }
        #errorOutput ul {
            color: red;
            padding-left: 20px;
        }
        #errorOutput ul.success {
            color: #008000;
        }
        #correctionOutput ul {
            color: #008080;
            padding-left: 20px;
        }
        body.dark #correctionOutput ul {
            color: #00d8d8;
        }
        #autoFixButton {
            margin-bottom: 10px;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 16px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #fff;
        }
        body.dark #autoFixButton {
            background-color: #333;
            border-color: #555;
            color: #fff;
        }
        #dropZone {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.2);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        #dropZone.active {
            display: flex;
        }
        #dropZone p {
            color: white;
            font-size: 24px;
            text-align: center;
            padding: 20px;
            border: 2px dashed white;
            background: rgba(0, 0, 0, 0.7);
        }
        #templateDialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border: 1px solid #ccc;
            border-radius: 4px;
            z-index: 2000;
            display: none;
            max-width: 90%;
            text-align: center;
        }
        body.dark #templateDialog {
            background: #333;
            border-color: #555;
            color: #fff;
        }
        #templateDialog select {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            font-size: 16px;
        }
        body.dark #templateDialog select {
            background: #444;
            color: #fff;
            border-color: #555;
        }
        #templateDialog button {
            width: 100px;
        }
        .instructions {
            margin-top: 10px;
            font-size: 14px;
            color: #333;
        }
        body.dark .instructions {
            color: #ccc;
        }
        .instructions h3 {
            margin-bottom: 5px;
        }
        .error-line {
            background-color: rgba(255, 0, 0, 0.2);
        }
        @media (max-width: 600px) {
            body {
                margin: 0 10px;
            }
            .header-row {
                flex-direction: column;
                align-items: flex-start;
            }
            .header-row h1 {
                font-size: 20px;
            }
            .theme-toggle {
                margin-left: 0;
                margin-top: 10px;
            }
            button, #autoFixButton {
                padding: 8px 16px;
                font-size: 14px;
            }
            .button-row-top, .button-row-bottom {
                gap: 5px;
            }
            .left-buttons, .right-buttons {
                gap: 5px;
            }
            #themeSelect {
                font-size: 14px;
                padding: 6px;
            }
            #dropZone p {
                font-size: 18px;
                padding: 15px;
            }
            #templateDialog {
                width: 80%;
                padding: 15px;
            }
            #templateDialog select {
                font-size: 14px;
            }
            .instructions {
                font-size: 12px;
            }
        }
        /* --- CodeMirror hints dark theme --- */
        body.dark .CodeMirror-hints {
            background: #23232b !important;
            color: #fff !important;
            border: 1px solid #444 !important;
        }
        body.dark .CodeMirror-hint {
            color: #fff !important;
            background: transparent !important;
        }
        body.dark .CodeMirror-hint-active {
            background: #444 !important;
            color: #fff !important;
        }
        body.dark .CodeMirror-hints::-webkit-scrollbar {
            background: #23232b;
        }
        body.dark .CodeMirror-hints::-webkit-scrollbar-thumb {
            background: #444;
        }
        #countdownContainer {
            border: 2px solid #888;
            border-radius: 12px;
            padding: 24px 16px;
            background: #f4f4f4;
            box-shadow: 0 2px 12px rgba(0,0,0,0.07);
            text-align: center;
        }
        #countdownTitle {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 12px;
        }
        #countdownTimer {
            font-size: 2em;
            font-family: 'Courier New', monospace;
            margin-bottom: 10px;
            color: #2a2a2a;
        }
        .countdown-links {
            margin-top: 18px;
            text-align: center;
        }
        .countdown-links-title {
            font-size: 1.1em;
            margin-bottom: 6px;
        }
        .countdown-link {
            display: inline-block;
            margin: 0 8px 8px 8px;
            font-weight: bold;
            text-decoration: underline;
        }
        .countdown-link.vk {
            color: #1565c0;
        }
        .countdown-link.yt {
            color: #e53935;
        }
        .countdown-changelog {
            margin-top: 10px;
            font-size: 1em;
        }
        .countdown-changelog a {
            color: #008080;
            text-decoration: underline;
            font-weight: bold;
        }
        body.dark #countdownContainer {
            background: #232323;
            border-color: #444;
            color: #fff;
        }
        body.dark #countdownTimer {
            color: #fff;
        }
        body.dark .countdown-link.vk {
            color: #42a5f5;
        }
        body.dark .countdown-link.yt {
            color: #ff5252;
        }
        body.dark .countdown-changelog a {
            color: #00d8d8;
        }
        #countdownBlock {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 40px auto 0 auto;
            max-width: 600px;
            margin-bottom: 100px;
        }
        .countdown-date {
            font-size: 0.8em;
            color: #888;
            margin-top: 5px;
        }
    </style>
</head>
<body class="system">
    <div id="dropZone"><p>Перетащите JSON-файл сюда</p></div>
    <div id="templateDialog">
        <p>Файл содержит несколько шаблонов. Выберите один:</p>
        <select id="templateSelect"></select>
        <button onclick="confirmTemplateSelection()">Выбрать</button>
    </div>
    <div class="container">
        <div class="header-row">
            <h1>Sprut.hub. Шаблоны. Редактор и валидатор</h1>
            <div class="theme-toggle">
                <select id="themeSelect" onchange="changeTheme()">
                    <option value="system">Системная</option>
                    <option value="light">Светлая</option>
                    <option value="dark">Тёмная</option>
                </select>
            </div>
        </div>
        <div class="button-row-top">
            <div class="left-buttons">
                <input type="file" id="uploadFile" accept=".json" style="display: none;">
                <input type="file" id="autoFixFileInput" accept=".json" style="display: none;">
                <button onclick="document.getElementById('uploadFile').click()">Открыть</button>
            </div>
            <div class="right-buttons">
                <button onclick="downloadTemplate()">Скачать</button>
            </div>
        </div>
        <div class="editor-container">
            <textarea id="jsonEditor"></textarea>
        </div>
        <div class="button-row-bottom">
            <div class="left-buttons">
                <button onclick="correctJson()">Исправить под требования Sprut.hub</button>
                <button onclick="validateJson()">Валидировать</button>
                <button onclick="formatJson()">Форматировать</button>
            </div>
            <div class="right-buttons">
                <div style="margin-bottom: 6px;">
                    <label style="display: flex; align-items: center; gap: 6px;">
                        <input type="checkbox" id="oneClickOpenFileCheckbox">
                        Открывать файл
                    </label>
                </div>
                <button onclick="oneClickFix()">Фикс в 1 клик</button>
            </div>
        </div>
        <div id="autoFixContainer"></div>
        <div id="correctionOutput"></div>
        <div id="errorOutput"></div>
        <div class="instructions">
            <h3>Инструкция по использованию</h3>
            <h4>Вариант 1 (быстрый):</h4>
            <ol>
                <li>Откройте файл шаблона</li>
                <li>Нажмите "Фикс в 1 клик"</li>
                <li>Обновить шаблон в Sprut.hub</li>
            </ol>
            <h4>Вариант 2 (ручной):</h4>
            <ol>
                <li>Откройте файл шаблона</li>
                <li>Если в одном файле содержится несколько шаблонов, то в появившемся окне выберите необходимый (в Sprut.hub с версии 1.12 в одном файле может быть только один шаблон). Для других шаблонов в этом файле операцию повторить</li>
                <li>Нажмите кнопку "Исправить под требования Sprut.hub" для автоматического исправления шаблона под требования Sprut.hub</li>
                <li>Нажмите кнопку "Валидировать" для проверки шаблона согласно JSON Schema</li>
                <li>Если в шаблоне есть ошибки валидации - нажмите "Попробовать исправить автоматически" и/или исправьте вручную код шаблона, чтобы он проходил валидацию, повторно нажав на кнопку "Валидировать"</li>
                <li>Нажмите кнопку "Форматировать" для форматирования кода</li>
                <li>Скачайте шаблон</li>
                <li>Обновить шаблон в Sprut.hub</li>
            </ol>
        </div>
        <div class="instructions" style="text-align: center; margin-top: 20px;">
            Автор Кирилл Ашихмин<br>
            Исходники: <a href="https://github.com/KirillAshikhmin/Sprut.Hub_Tools" target="_blank">https://github.com/KirillAshikhmin/Sprut.Hub_Tools</a><br>
            Телеграм: <a href="https://t.me/smart_sputnik" target="_blank">https://t.me/smart_sputnik</a>
        </div>
    </div>

    <!-- Блок обратного отсчёта и ссылок -->
    <div id="countdownBlock">
        <div id="countdownContainer">
            <div id="countdownTitle">До стрима и выхода беты 1.12.2 осталось:</div>
            <div id="countdownTimer"></div>
            <div class="countdown-date">до 28 июня 2025, 20:00 МСК</div>
        </div>
        <div class="countdown-links">
            <div class="countdown-links-title">Смотреть стрим:</div>
            <a href="https://vkvideo.ru/video-119758871_456239216" target="_blank" class="countdown-link vk">VK Видео</a>
            <a href="https://www.youtube.com/sprut666666" target="_blank" class="countdown-link yt">YouTube</a>
            <div class="countdown-changelog">Чейнджлог новой версии:<br>
                <a href="https://t.me/SprutHub_Changelog" target="_blank">@SprutHub_Changelog</a>
            </div>
        </div>
    </div>

    <script>
        // Инициализация CodeMirror
        const editor = CodeMirror.fromTextArea(document.getElementById('jsonEditor'), {
            mode: 'application/json',
            lineNumbers: true,
            indentUnit: 2,
            foldGutter: true,
            gutters: ['CodeMirror-linenumbers', 'CodeMirror-foldgutter'],
            viewportMargin: Infinity
        });

        // Загрузка JSON Schema
        let schema = {};
        let allowedInputTypesFromSchema = [];
        
        fetch('./schema.json')
            .then(response => response.json())
            .then(data => {
                schema = data;
                schemaHintsTree = buildSchemaHintsTree(data);
            })
            .catch(error => {
                console.error('Ошибка загрузки schema.json:', error);
                document.getElementById('errorOutput').innerHTML = `<ul><li>Ошибка загрузки schema.json: ${error.message}</li></ul>`;
            });
            
        let schemaHintsTree = null;
        function buildSchemaHintsTree(schema) {
            // Рекурсивно строим дерево ключей и enum-значений
            function walk(def, path = []) {
                let result = {};
                if (def.properties) {
                    for (const key in def.properties) {
                        const prop = def.properties[key];
                        result[key] = {
                            type: prop.type,
                            description: prop.description || '',
                            enum: prop.enum || null,
                            properties: prop.properties ? walk(prop, path.concat(key)) : null
                        };
                    }
                }
                return result;
            }
            
            let tree = {};
            
            // Корневые свойства
            if (schema.properties) {
                tree = walk(schema);
            }
            
            return tree;
        }

        // Загрузка sh_types.json
        let shTypes = [];
        fetch('./sh_types.json')
            .then(response => response.json())
            .then(data => shTypes = data.result?.service?.types?.types || [])
            .catch(error => {
                console.error('Ошибка загрузки sh_types.json:', error);
                document.getElementById('errorOutput').innerHTML = `<ul><li>Ошибка загрузки sh_types.json: ${error.message}</li></ul>`;
            });

        // Управление темами
        function changeTheme() {
            const themeSelect = document.getElementById('themeSelect');
            const theme = themeSelect.value;
            let effectiveTheme = theme;

            if (theme === 'system') {
                effectiveTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
            }

            document.body.className = effectiveTheme;
            localStorage.setItem('theme', theme);
            editor.setOption('theme', effectiveTheme === 'dark' ? 'dracula' : 'default');
        }

        // Инициализация темы
        const savedTheme = localStorage.getItem('theme') || 'system';
        document.getElementById('themeSelect').value = savedTheme;
        changeTheme();

        // Обновление темы при изменении системной темы
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
            if (document.getElementById('themeSelect').value === 'system') {
                changeTheme();
            }
        });

        // Флаг для автозапуска фикса после выбора шаблона
        let oneClickFixMode = false;

        // Функция выбора шаблона
        let selectedTemplateCallback = null;
        function selectTemplateWithDropdown(json, callback) {
            if (!Array.isArray(json) || json.length <= 1) {
                callback(json);
                return;
            }

            const select = document.getElementById('templateSelect');
            select.innerHTML = '';
            json.forEach((template, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.text = `Name: ${template.name || ''}, Manufacturer: ${template.manufacturer || 'без производителя'}, Model: ${template.model || 'без модели'}`;
                select.appendChild(option);
            });

            selectedTemplateCallback = (selectedIndex) => {
                callback(selectedIndex);
                if (oneClickFixMode) {
                    oneClickFixMode = false;
                    setTimeout(() => oneClickFixRun(), 100);
                }
            };
            document.getElementById('templateDialog').style.display = 'block';
        }

        function confirmTemplateSelection() {
            const select = document.getElementById('templateSelect');
            const selectedIndex = parseInt(select.value);
            document.getElementById('templateDialog').style.display = 'none';
            if (selectedTemplateCallback) {
                selectedTemplateCallback(selectedIndex);
            }
        }

        // Загрузка файла
        document.getElementById('uploadFile').addEventListener('change', function(event) {
            // При ручном открытии файла всегда сбрасываем автофикс
            oneClickFixMode = false;
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = async function(e) {
                    try {
                        const fileContent = e.target.result;
                        let parsed;
                        try {
                            parsed = JSON.parse(fileContent);
                        } catch (err) {
                            document.getElementById('errorOutput').innerHTML = `<ul><li>Ошибка чтения файла: ${err.message}</li></ul>`;
                            return;
                        }
                        // Очищаем выводы при открытии файла
                        document.getElementById('errorOutput').textContent = '';
                        document.getElementById('correctionOutput').textContent = '';
                        document.getElementById('autoFixContainer').innerHTML = '';
                        if (Array.isArray(parsed) && parsed.length > 1) {
                            // Несколько шаблонов - показываем диалог выбора
                            selectTemplateWithDropdown(parsed, (selectedIndex) => {
                                const selectedTemplate = parsed[selectedIndex];
                                editor.setValue(JSON.stringify(selectedTemplate, null, 2));
                                editor.refresh();
                            });
                        } else {
                            // Один шаблон - просто загружаем в редактор
                            const template = Array.isArray(parsed) ? parsed[0] : parsed;
                            editor.setValue(JSON.stringify(template, null, 2));
                            editor.refresh();
                        }
                    } catch (err) {
                        document.getElementById('errorOutput').innerHTML = `<ul><li>Ошибка чтения файла: ${err.message}</li></ul>`;
                    }
                };
                reader.readAsText(file);
            }
        });

        // Drag & Drop
        const dropZone = document.getElementById('dropZone');
        let dragCounter = 0;

        document.addEventListener('dragenter', (e) => {
            e.preventDefault();
            dragCounter++;
            dropZone.classList.add('active');
        });

        document.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        document.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dragCounter--;
            if (dragCounter === 0) {
                dropZone.classList.remove('active');
            }
        });

        document.addEventListener('drop', (e) => {
            e.preventDefault();
            dragCounter = 0;
            dropZone.classList.remove('active');
            oneClickFixMode = false;
            const file = e.dataTransfer.files[0];
            if (file && file.type === 'application/json') {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const json = JSON.parse(e.target.result);
                        selectTemplateWithDropdown(json, (selectedIndex) => {
                            const selectedTemplate = Array.isArray(json) ? json[selectedIndex] : json;
                            editor.setValue(JSON.stringify(selectedTemplate, null, 2));
                            document.getElementById('errorOutput').textContent = '';
                            document.getElementById('correctionOutput').textContent = '';
                            document.getElementById('autoFixContainer').innerHTML = '';
                            editor.refresh();
                        });
                    } catch (e) {
                        document.getElementById('errorOutput').innerHTML = `<ul><li>Ошибка синтаксиса JSON: ${e.message}</li></ul>`;
                    }
                };
                reader.readAsText(file);
            } else {
                document.getElementById('errorOutput').innerHTML = `<ul><li>Ошибка: Перетащите файл в формате JSON</li></ul>`;
            }
        });

        // Флаг для контроля форматирования и скачивания из oneClickFixRun
        let formatFromOneClick = false;

        function formatJson() {
            try {
                const value = editor.getValue();
                if (!value.trim()) {
                    document.getElementById('errorOutput').innerHTML = `<ul><li>Необходимо сперва открыть файл шаблона</li></ul>`;
                    return;
                }
                // Очищаем выводы при нажатии кнопки (если не из oneClickFixRun)
                if (!formatFromOneClick) {
                    document.getElementById('errorOutput').textContent = '';
                    document.getElementById('correctionOutput').textContent = '';
                    document.getElementById('autoFixContainer').innerHTML = '';
                }
                const json = JSON.parse(value);
                editor.setValue(JSON.stringify(json, null, 2));
                if (!formatFromOneClick) {
                    document.getElementById('correctionOutput').innerHTML = `<ul><li>Форматирование успешно выполнено</li></ul>`;
                }
                editor.refresh();
            } catch (e) {
                document.getElementById('errorOutput').innerHTML = `<ul><li>Ошибка форматирования: ${e.message}</li></ul>`;
            }
        }

        // Подсветка строки с ошибкой
        function highlightErrorLine(path, jsonStr) {
            if (!path) {
                return 1;
            }

            const lines = jsonStr.split('\n');
            const segments = path.replace(/^\./, '').split(/\.|\[(\d+)\]/).filter(p => p && p.trim() !== '');

            let searchScope = jsonStr;
            let totalOffsetChars = 0;

            for (const segment of segments) {
                const isArrayIndex = /^\d+$/.test(segment);

                if (isArrayIndex) {
                    const index = parseInt(segment, 10);
                    const arrayStartMatch = /^\s*\[/.exec(searchScope);
                    if (!arrayStartMatch) return -1;

                    let searchFrom = arrayStartMatch[0].length;
                    let elementCount = 0;
                    let elementStart = -1;

                    while (elementCount <= index) {
                        let inString = false;
                        let braceDepth = 0;
                        let bracketDepth = 0;
                        let foundStart = false;

                        for (let i = searchFrom; i < searchScope.length; i++) {
                            if (!foundStart) {
                                if (/\s|,/.test(searchScope[i])) continue;
                                elementStart = i;
                                foundStart = true;
                            }
                            
                            const char = searchScope[i];
                            const prevChar = i > 0 ? searchScope[i - 1] : null;

                            if (char === '"' && prevChar !== '\\') {
                                inString = !inString;
                            }

                            if (!inString) {
                                if (char === '{') braceDepth++;
                                else if (char === '}') braceDepth--;
                                else if (char === '[') bracketDepth++;
                                else if (char === ']') bracketDepth--;

                                if (braceDepth === 0 && bracketDepth === 0 && (char === ',' || i === searchScope.length - 1)) {
                                     if (elementCount === index) {
                                        totalOffsetChars += elementStart;
                                        searchScope = searchScope.substring(elementStart, i + 1);
                                    }
                                    searchFrom = i + 1;
                                    break;
                                }
                                if ( (braceDepth === -1 || bracketDepth === -1) ) {
                                    if (elementCount === index) {
                                        totalOffsetChars += elementStart;
                                        searchScope = searchScope.substring(elementStart, i);
                                    }
                                    searchFrom = i;
                                    break;
                                }
                            }
                             if (i === searchScope.length - 1) { // End of scope
                                if (elementCount === index) {
                                    totalOffsetChars += elementStart;
                                    searchScope = searchScope.substring(elementStart);
                                }
                                searchFrom = i + 1;
                            }
                        }
                        elementCount++;
                    }

                } else { // It's a key
                    const keyRegex = new RegExp(`"${segment}"\\s*:`);
                    const match = keyRegex.exec(searchScope);
                    if (!match) return -1;
                    totalOffsetChars += match.index + match[0].length;
                    searchScope = searchScope.substring(match.index + match[0].length);
                }
            }

            const lineNumber = jsonStr.substring(0, totalOffsetChars).split('\n').length;
            if (lineNumber > 0 && lineNumber <= lines.length) {
                editor.addLineClass(lineNumber - 1, 'background', 'error-line');
            }
            return lineNumber;
        }

        // Очистка подсветки ошибок
        function clearErrorHighlights() {
            for (let i = 0; i < editor.lineCount(); i++) {
                editor.removeLineClass(i, 'background', 'error-line');
            }
        }

        // Валидация сервисов и характеристик
        function validateServiceAndCharacteristics(json, errors, warnings, jsonStr) {
            if (json.services && Array.isArray(json.services)) {
                json.services.forEach((service, serviceIndex) => {
                    if (!service.type) {
                        const line = highlightErrorLine(`services[${serviceIndex}]`, jsonStr);
                        errors.push(`Сервис ${serviceIndex + 1}: Отсутствует поле type (строка ${line})`);
                        return;
                    }

                    const serviceDef = shTypes.find(t => t.type === service.type);
                    if (!serviceDef) {
                        const line = highlightErrorLine(`services[${serviceIndex}].type`, jsonStr);
                        errors.push(`Сервис ${service.type}: Тип сервиса не найден (строка ${line})`);
                        return;
                    }

                    if (!service.characteristics || !Array.isArray(service.characteristics)) {
                        const line = highlightErrorLine(`services[${serviceIndex}].characteristics`, jsonStr);
                        errors.push(`Сервис ${service.type}: Отсутствует или некорректно поле characteristics (строка ${line})`);
                        return;
                    }

                    service.characteristics.forEach((char, charIndex) => {
                        if (!char.type) {
                            const line = highlightErrorLine(`services[${serviceIndex}].characteristics[${charIndex}]`, jsonStr);
                            errors.push(`Сервис ${service.type}, характеристика ${charIndex + 1}: Отсутствует поле type (строка ${line})`);
                            return;
                        }

                        const supportedCharacteristics = [
                            ...(serviceDef.required || []),
                            ...(serviceDef.optional || [])
                        ];
                        const charDef = supportedCharacteristics.find(c => c.type === char.type);
                        if (!charDef) {
                            const line = highlightErrorLine(`services[${serviceIndex}].characteristics[${charIndex}].type`, jsonStr);
                            warnings.push(`Сервис ${service.type}: Характеристика ${char.type} не поддерживается (строка ${line})`);
                        }
                    });
                });
            }
        }

        // Локализация ошибок JSON Schema
        function translateAjvError(error, json, jsonStr) {
            const path = error.dataPath || '';
            const message = error.message;
            let translated = '';
            
            let contextPrefix = '';
            let highlightPath = path;

            const serviceMatch = path.match(/\.services\[(\d+)\]/);
            if (serviceMatch) {
                try {
                    const serviceIndex = parseInt(serviceMatch[1], 10);
                    const service = json.services[serviceIndex];
                    if (service && service.name) {
                        contextPrefix += `В сервисе "${service.name}"`;
                    } else if (service && service.type) {
                        contextPrefix += `В сервисе типа "${service.type}"`;
                    }

                    const charMatch = path.match(/\.characteristics\[(\d+)\]/);
                    if (charMatch) {
                        const charIndex = parseInt(charMatch[1], 10);
                        const characteristic = json.services[serviceIndex].characteristics[charIndex];
                        if (characteristic && characteristic.type) {
                            contextPrefix += `, характеристика "${characteristic.type}"`;
                        }
                        contextPrefix += ': ';
                    } else {
                        contextPrefix += ': ';
                    }
                } catch(e) {
                    contextPrefix = ''; // Reset on error
                }
            }

            const line = highlightErrorLine(path.replace(/^\./, ''), jsonStr);

            switch (error.keyword) {
                case 'additionalProperties':
                    const extraProp = error.params.additionalProperty;
                    translated = `Поле "${extraProp}" в ${path || 'корне объекта'} не разрешено по схеме (строка ${line})`;
                    break;
                case 'required':
                    translated = `В ${path || 'объекте'} отсутствует обязательное поле "${error.params.missingProperty}" (строка ${line})`;
                    break;
                case 'type':
                    translated = `Поле ${path} имеет неверный тип: ожидается ${error.params.type}, найдено ${typeof json[path.split('.').reduce((o, k) => o && o[k], json)]} (строка ${line})`;
                    break;
                case 'enum':
                    translated = `Поле ${path} имеет недопустимое значение. Допустимые значения: ${error.params.allowedValues.join(', ')} (строка ${line})`;
                    break;
                case 'anyOf':
                    translated = `Поле ${path} должно соответствовать одной из схем, определённых в JSON Schema (строка ${line})`;
                    break;
                case 'dependencies':
                    translated = `Поле ${path} должно содержать свойство ${error.params.missingProperty}, если присутствует ${error.params.property} (строка ${line})`;
                    break;
                default:
                    translated = `Ошибка в ${path}: ${message} (строка ${line})`;
            }

            return { message: translated, line };
        }

        // Автоматическое исправление ошибок JSON Schema
        function autoFixJson(isManual = true) {
            try {
                // Очищаем выводы при нажатии кнопки только если вызов ручной
                document.getElementById('errorOutput').textContent = '';
                document.getElementById('autoFixContainer').innerHTML = '';
                if (isManual) {
                    document.getElementById('correctionOutput').textContent = '';
                }
                
                let json = JSON.parse(editor.getValue());
                const corrections = [];
                const ajv = new Ajv({ allErrors: true });
                const validate = ajv.compile(schema);
                validate(json);

                if (validate.errors) {
                    validate.errors.forEach(error => {
                        const path = error.dataPath.split('.').filter(p => p).reduce((obj, key) => {
                            if (key.includes('[')) {
                                const [arrayKey, index] = key.split(/\[(\d+)\]/).filter(Boolean);
                                return obj[arrayKey][parseInt(index)];
                            }
                            return obj[key];
                        }, json);

                        if (error.keyword === 'additionalProperties') {
                            const extraProp = error.params.additionalProperty;
                            const parentPath = error.dataPath.split('.').filter(p => p);
                            let parent = json;
                            for (let i = 0; i < parentPath.length; i++) {
                                let key = parentPath[i];
                                if (key.includes('[')) {
                                    const [arrayKey, index] = key.split(/\[(\d+)\]/).filter(Boolean);
                                    parent = parent[arrayKey][parseInt(index)];
                                } else {
                                    parent = parent[key];
                                }
                            }
                            delete parent[extraProp];
                            corrections.push(`Удалено недопустимое поле "${extraProp}" в ${error.dataPath || 'корне объекта'}`);
                        } else if (error.keyword === 'dependencies' && error.params.missingProperty === 'type') {
                            const linkPath = error.dataPath.split('.').filter(p => p);
                            let link = json;
                            for (let i = 0; i < linkPath.length; i++) {
                                let key = linkPath[i];
                                if (key.includes('[')) {
                                    const [arrayKey, index] = key.split(/\[(\d+)\]/).filter(Boolean);
                                    link = link[arrayKey][parseInt(index)];
                                } else {
                                    link = link[key];
                                }
                            }
                            link.type = 'unknown';
                            corrections.push(`Добавлено поле type="unknown" в ${error.dataPath}`);
                        }
                    });
                }

                editor.setValue(JSON.stringify(json, null, 2));
                if (corrections.length > 0) {
                    document.getElementById('correctionOutput').innerHTML += `<ul>${corrections.map(c => `<li>${c}</li>`).join('')}</ul>`;
                } else {
                    document.getElementById('correctionOutput').innerHTML += '<ul><li>Автоматические исправления не применялись</li></ul>';
                }
                clearErrorHighlights();
                editor.refresh();
                
                // Автоматическая повторная валидация после исправлений
                if (corrections.length > 0) {
                    setTimeout(() => {
                        validateJsonInternal(true);
                    }, 100);
                }
            } catch (e) {
                document.getElementById('errorOutput').innerHTML = `<ul><li>Ошибка автоматического исправления: ${e.message}</li></ul>`;
            }
        }

        // Валидация JSON
        function validateJson(suppressCorrectionOutput = false) {
            const value = editor.getValue();
            if (!value.trim()) {
                document.getElementById('errorOutput').innerHTML = `<ul><li>Необходимо сперва открыть файл шаблона</li></ul>`;
                return;
            }
            // Очищаем выводы при нажатии кнопки
            document.getElementById('errorOutput').textContent = '';
            if (!suppressCorrectionOutput) document.getElementById('correctionOutput').textContent = '';
            document.getElementById('autoFixContainer').innerHTML = '';
            validateJsonInternal(false, suppressCorrectionOutput);
        }

        // Внутренняя функция валидации с параметром для автоматической валидации
        function validateJsonInternal(isAutoValidation = false, suppressCorrectionOutput = false) {
            try {
                const jsonStr = editor.getValue();
                const json = JSON.parse(jsonStr);
                if (Array.isArray(json)) {
                    const line = highlightErrorLine('', jsonStr);
                    document.getElementById('errorOutput').innerHTML = `<ul><li>Ошибка: Введите один шаблон (объект JSON), а не массив (строка ${line})</li></ul>`;
                    document.getElementById('autoFixContainer').innerHTML = '';
                    return;
                }

                clearErrorHighlights();
                const errors = [];
                const warnings = [];
                const errorLines = new Set();

                const hasTopicGetOrSet = json.services && Array.isArray(json.services) && json.services.some(service => 
                    service.characteristics && Array.isArray(service.characteristics) && service.characteristics.some(char => 
                        char.link && (Array.isArray(char.link) ? char.link : [char.link]).some(link => link.topicGet || link.topicSet)
                    )
                );

                if (hasTopicGetOrSet) {
                    if (!json.modelId || !/\(.*\)/.test(json.modelId)) {
                        const line = highlightErrorLine('modelId', jsonStr);
                        errors.push(`В MQTT шаблонах должно быть регулярное выражение в modelId (строка ${line})`);
                        errorLines.add(line);
                    }

                    json.services.forEach((service, serviceIndex) => {
                        if (service.characteristics && Array.isArray(service.characteristics)) {
                            service.characteristics.forEach((char, charIndex) => {
                                if (char.link) {
                                    const links = Array.isArray(char.link) ? char.link : [char.link];
                                    links.forEach((link, linkIndex) => {
                                        if (link.topicGet && !link.topicGet.includes('(1)')) {
                                            const line = highlightErrorLine(`services[${serviceIndex}].characteristics[${charIndex}].link[${linkIndex}].topicGet`, jsonStr);
                                            errors.push(`Поле topicGet в характеристике ${char.type || 'без типа'} не содержит подстроку "(1)" (строка ${line})`);
                                            errorLines.add(line);
                                        }
                                        if (link.topicSet && !link.topicSet.includes('(1)')) {
                                            const line = highlightErrorLine(`services[${serviceIndex}].characteristics[${charIndex}].link[${linkIndex}].topicSet`, jsonStr);
                                            errors.push(`Поле topicSet в характеристике ${char.type || 'без типа'} не содержит подстроку "(1)" (строка ${line})`);
                                            errorLines.add(line);
                                        }
                                    });
                                }
                            });
                        }
                    });
                }

                validateServiceAndCharacteristics(json, errors, warnings, jsonStr);

                const ajv = new Ajv({ allErrors: true });
                const validate = ajv.compile(schema);
                const valid = validate(json);

                let errorOutput = '';
                if (!valid) {
                    const allErrors = validate.errors || [];
                    // Filter out redundant 'anyOf' errors that have a more specific error reported
                    const filteredErrors = allErrors.filter(error => {
                        if (error.keyword !== 'anyOf') {
                            return true;
                        }
                        const path = error.dataPath;
                        const hasMoreSpecificError = allErrors.some(otherError => {
                            return otherError !== error && otherError.dataPath.startsWith(path) && otherError.dataPath.length > path.length;
                        });
                        return !hasMoreSpecificError;
                    });
                    
                    const schemaErrors = filteredErrors
                            .map(err => translateAjvError(err, json, jsonStr))
                            .map(({ message }) => `<li>${message}</li>`)
                            .join('')
                        ;
                    errorOutput += schemaErrors;
                }
                if (errors.length > 0) {
                    errorOutput += errors.map(err => `<li>${err}</li>`).join('');
                }
                if (warnings.length > 0) {
                    errorOutput += warnings.map(warn => `<li>Предупреждение: ${warn}</li>`).join('');
                }

                if (errorOutput) {
                    document.getElementById('autoFixContainer').innerHTML = `<button id="autoFixButton" onclick="autoFixJson()">Попробовать исправить автоматически</button>`;
                    document.getElementById('errorOutput').innerHTML = `<ul>${errorOutput}</ul>`;
                    if (!isAutoValidation && !suppressCorrectionOutput) {
                        document.getElementById('correctionOutput').textContent = '';
                    }
                } else {
                    document.getElementById('autoFixContainer').innerHTML = '';
                    document.getElementById('errorOutput').innerHTML = '';
                    if (!isAutoValidation && !suppressCorrectionOutput) {
                        document.getElementById('correctionOutput').innerHTML = `<ul><li>JSON валиден по схеме</li></ul>`;
                    }
                }
                editor.refresh();
            } catch (e) {
                const line = e.lineNumber || 1;
                clearErrorHighlights();
                editor.addLineClass(line - 1, 'background', 'error-line');
                document.getElementById('errorOutput').innerHTML = `<ul><li>Ошибка синтаксиса JSON: ${e.message} (строка ${line})</li></ul>`;
                document.getElementById('autoFixContainer').innerHTML = '';
            }
        }

        // Логика всех исправлений, вынесенная для переиспользования
        function applyCorrections(jsonToCorrect) {
            const newJson = JSON.parse(JSON.stringify(jsonToCorrect)); // Глубокая копия
            const corrections = [];

            // Преобразование topicSearch в modelId
            let topicSearchValue = null;
            function findAndRemoveTopicSearch(obj) {
                let removed = false;
                for (const key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key)) {
                        if (key === 'topicSearch') {
                            const value = Array.isArray(obj[key]) ? obj[key][0] : obj[key];
                            if (!topicSearchValue && value) { // Сохраняем только первое найденное непустое значение
                                topicSearchValue = value;
                            }
                            delete obj[key];
                            removed = true;
                        } else if (typeof obj[key] === 'object' && obj[key] !== null) {
                            if (findAndRemoveTopicSearch(obj[key])) {
                                removed = true;
                            }
                        }
                    }
                }
                return removed;
            }

            if (findAndRemoveTopicSearch(newJson)) {
                if (topicSearchValue) {
                    newJson.modelId = topicSearchValue;
                    corrections.push(`Значение topicSearch перенесено в modelId и все его вхождения удалены.`);
                } else {
                    corrections.push(`Пустое поле topicSearch удалено из шаблона.`);
                }
            }

            // Key renames
            let renameCorrectionAdded = false;
            const renameMap = {
                mapOut: 'outMap',
                mapIn: 'map',
                inMap: 'map',
                funcOut: 'outFunc',
                func: 'inFunc',
                funcIn: 'inFunc'
            };

            function renameRecursively(obj) {
                if (!obj || typeof obj !== 'object') {
                    return;
                }
                if (Array.isArray(obj)) {
                    obj.forEach(renameRecursively);
                    return;
                }

                let renamedInThisObject = false;
                for (const oldKey in renameMap) {
                    if (obj.hasOwnProperty(oldKey)) {
                        const newKey = renameMap[oldKey];
                        obj[newKey] = obj[oldKey];
                        delete obj[oldKey];
                        renamedInThisObject = true;
                    }
                }

                if (renamedInThisObject && !renameCorrectionAdded) {
                    corrections.push('Выполнено переименование полей (mapOut->outMap, inMap/mapIn->map, funcOut->outFunc, func/funcIn->inFunc)');
                    renameCorrectionAdded = true;
                }

                for (const key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        renameRecursively(obj[key]);
                    }
                }
            }
            
            renameRecursively(newJson);

            // Исправление template
            if (typeof newJson.template === 'string') {
                newJson.template = [newJson.template];
                corrections.push(`Поле template преобразовано в массив`);
            }

            // Исправление manufacturerId и modelId
            if (typeof newJson.manufacturerId === 'string' && newJson.manufacturerId.startsWith('(') && newJson.manufacturerId.endsWith(')')) {
                newJson.manufacturerId = newJson.manufacturerId.slice(1, -1);
                corrections.push(`Удалены скобки из manufacturerId`);
            }
            if (typeof newJson.modelId === 'string' && newJson.modelId.startsWith('(') && newJson.modelId.endsWith(')')) {
                newJson.modelId = newJson.modelId.slice(1, -1);
                corrections.push(`Удалены скобки из modelId`);
            }

            // Исправление link в characteristics
            if (newJson.services && Array.isArray(newJson.services)) {
                newJson.services.forEach((service, serviceIndex) => {
                    if (service.characteristics && Array.isArray(service.characteristics)) {
                        service.characteristics.forEach(characteristic => {
                            if (characteristic.type === 'Float') {
                                characteristic.type = 'Double';
                                const serviceName = service.name ? ` сервиса "${service.name}"` : '';
                                corrections.push(`Характеристика ${characteristic.type || ''}${serviceName}: Тип Float заменён на Double`);
                            }
                            if (characteristic.link && !Array.isArray(characteristic.link)) {
                                characteristic.link = [characteristic.link];
                                const serviceName = service.name ? ` сервиса "${service.name}"` : '';
                                corrections.push(`Поле link в характеристике ${characteristic.type || ''}${serviceName} преобразовано в массив`);
                            }
                        });
                    }
                });
            }

            // Исправление link и типа в options
            if (newJson.options && Array.isArray(newJson.options)) {
                newJson.options.forEach(option => {
                    // 1. Переименование input -> inputType
                    if (option.hasOwnProperty('input')) {
                        option.inputType = option.input;
                        delete option.input;
                        corrections.push(`В опции ${option.name || ''} поле input переименовано в inputType`);
                    }
                    // 2. Замена значения inputType на допустимое из схемы
                    if (option.hasOwnProperty('inputType') && typeof option.inputType === 'string' && Array.isArray(allowedInputTypesFromSchema)) {
                        const found = allowedInputTypesFromSchema.find(v => v.toLowerCase() === option.inputType.toLowerCase());
                        if (found && found !== option.inputType) {
                            corrections.push(`В опции ${option.name || ''} значение inputType заменено с "${option.inputType}" на "${found}"`);
                            option.inputType = found;
                        }
                    }
                    if (option.type === 'Float') {
                        option.type = 'Double';
                        corrections.push(`Опция ${option.name || ''}: Тип Float заменён на Double`);
                    }
                    if (option.link && !Array.isArray(option.link)) {
                        option.link = [option.link];
                        corrections.push(`Поле link в опции "${option.name || ''}" преобразовано в массив`);
                    }
                });
            }

            // Исправление link в init
            let initLinkCorrectionAdded = false;
            if (newJson.init && Array.isArray(newJson.init)) {
                newJson.init.forEach((initCmd) => {
                    if (initCmd.link && !Array.isArray(initCmd.link)) {
                        initCmd.link = [initCmd.link];
                        if (!initLinkCorrectionAdded) {
                            corrections.push(`Поле link в командах инициализации (init) преобразовано в массив`);
                            initLinkCorrectionAdded = true;
                        }
                    }
                });
            }

            // Reorder keys for better readability before displaying
            const keyOrder = [
                'name', 'description', 'optional', 'comment', 'overview', 'room', 
                'manufacturer', 'model', 'manufacturerId', 'modelId', 'status', 
                'catalogId', 'issue', 'url', 'ali', 'ali2', 'minRevision', 
                'maxRevision', 'powerMode', 'otaSupport', 'otaReInitAfterUpdate', 
                'imageType', 'date', 'TODO', 'visible', 'template', 'init', 
                'services', 'options'
            ];

            const orderedJson = {};
            const remainingKeys = { ...newJson };

            for (const key of keyOrder) {
                if (Object.prototype.hasOwnProperty.call(newJson, key)) {
                    orderedJson[key] = newJson[key];
                    delete remainingKeys[key];
                }
            }

            Object.assign(orderedJson, remainingKeys);

            return { finalJson: orderedJson, corrections };
        }

        // Исправление JSON под требования Sprut.hub
        function correctJson() {
            try {
                const value = editor.getValue();
                if (!value.trim()) {
                    document.getElementById('errorOutput').innerHTML = `<ul><li>Необходимо сперва открыть файл шаблона</li></ul>`;
                    return;
                }
                // Очищаем выводы при нажатии кнопки
                document.getElementById('errorOutput').textContent = '';
                document.getElementById('correctionOutput').textContent = '';
                document.getElementById('autoFixContainer').innerHTML = '';
                
                let json = JSON.parse(value);
                oneClickFixMode = false;
                selectTemplateWithDropdown(json, (selectedIndex) => {
                    const selectedTemplate = Array.isArray(json) ? (selectedIndex !== undefined ? json[selectedIndex] : json) : json;
                    
                    const { finalJson, corrections } = applyCorrections(selectedTemplate);

                    editor.setValue(JSON.stringify(finalJson, null, 2));
                    document.getElementById('correctionOutput').innerHTML = corrections.length > 0
                        ? `<ul>${corrections.map(c => `<li>${c}</li>`).join('')}</ul>`
                        : '<ul><li>Исправления не требовались</li></ul>';
                    clearErrorHighlights();
                    editor.refresh();
                });
            } catch (e) {
                document.getElementById('errorOutput').innerHTML = `<ul><li>Ошибка исправления: ${e.message}</li></ul>`;
            }
        }

        // Фикс в 1 клик
        async function oneClickFix() {
            const openFileFirst = document.getElementById('oneClickOpenFileCheckbox').checked;
            if (openFileFirst) {
                // Открыть диалог выбора файла, затем продолжить после выбора
                const fileInput = document.getElementById('autoFixFileInput');
                fileInput.onchange = async function(event) {
                    const file = event.target.files[0];
                    event.target.value = '';
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = async function(e) {
                            try {
                                const fileContent = e.target.result;
                                let parsed;
                                try {
                                    parsed = JSON.parse(fileContent);
                                } catch (err) {
                                    document.getElementById('errorOutput').innerHTML = `<ul><li>Ошибка чтения файла: ${err.message}</li></ul>`;
                                    return;
                                }
                                
                                // Очищаем выводы при открытии файла
                                document.getElementById('errorOutput').textContent = '';
                                document.getElementById('correctionOutput').textContent = '';
                                document.getElementById('autoFixContainer').innerHTML = '';
                                
                                if (Array.isArray(parsed) && parsed.length > 1) {
                                    // Несколько шаблонов - показываем диалог выбора с автоисправлением
                                    oneClickFixMode = true;
                                    selectTemplateWithDropdown(parsed, (selectedIndex) => {
                                        const selectedTemplate = parsed[selectedIndex];
                                        editor.setValue(JSON.stringify(selectedTemplate, null, 2));
                                        editor.refresh();
                                    });
                                } else {
                                    // Один шаблон - загружаем и запускаем автоисправление
                                    const template = Array.isArray(parsed) ? parsed[0] : parsed;
                                    editor.setValue(JSON.stringify(template, null, 2));
                                    editor.refresh();
                                    await oneClickFixRun();
                                }
                            } catch (err) {
                                document.getElementById('errorOutput').innerHTML = `<ul><li>Ошибка чтения файла: ${err.message}</li></ul>`;
                            }
                        };
                        reader.readAsText(file);
                    }
                };
                fileInput.click();
                return;
            }
            await oneClickFixRun();
        }

        // Вынесенная логика для фикса в 1 клик (без открытия файла)
        async function oneClickFixRun() {
            const btn = document.querySelector('button[onclick="oneClickFix()"]');
            btn.disabled = true;
            btn.textContent = 'Выполняется...';
            document.getElementById('correctionOutput').innerHTML = '<ul><li>Запущен фикс в 1 клик...</li></ul>';

            try {
                // Step 1: Run corrections
                const json = JSON.parse(editor.getValue());
                if (Array.isArray(json)) {
                    document.getElementById('errorOutput').innerHTML = `<ul><li>"Фикс в 1 клик" не работает с файлами, содержащими несколько шаблонов. Пожалуйста, выберите и загрузите один шаблон в редактор.</li></ul>`;
                    return;
                }
                const { finalJson, corrections } = applyCorrections(json);
                editor.setValue(JSON.stringify(finalJson, null, 2));
                if (corrections.length > 0) {
                    document.getElementById('correctionOutput').innerHTML += `<ul>${corrections.map(c => `<li>${c}</li>`).join('')}</ul>`;
                } else {
                    document.getElementById('correctionOutput').innerHTML += '<ul><li>Исправления не требовались.</li></ul>';
                }
                
                await new Promise(r => setTimeout(r, 50));

                // Step 2: Validate
                validateJson(true);
                let hasErrors = document.getElementById('errorOutput').innerHTML.trim() !== '';

                if (!hasErrors) {
                    document.getElementById('correctionOutput').innerHTML += '<ul><li>Скачивание...</li></ul>';
                    formatFromOneClick = true;
                    formatJson();
                    formatFromOneClick = false;
                    downloadTemplate();
                    return;
                }

                // Step 3: Errors found, try auto-fix
                document.getElementById('correctionOutput').innerHTML += '<ul><li>Найдены ошибки, попытка автоматического исправления...</li></ul>';
                autoFixJson(false);

                await new Promise(r => setTimeout(r, 200)); // wait for autoFixJson's internal timeout

                // Step 4: Check validation result again
                hasErrors = document.getElementById('errorOutput').innerHTML.trim() !== '';

                if (!hasErrors) {
                    document.getElementById('correctionOutput').innerHTML += '<ul><li>Авто-исправление успешно! Скачивание...</li></ul>';
                    formatFromOneClick = true;
                    formatJson();
                    formatFromOneClick = false;
                    downloadTemplate();
                } else {
                    document.getElementById('correctionOutput').innerHTML += '<ul><li>Не удалось исправить все ошибки автоматически. Пожалуйста, исправьте их вручную.</li></ul>';
                }
            } catch (e) {
                document.getElementById('errorOutput').innerHTML = `<ul><li>Произошла ошибка в процессе "Фикс в 1 клик": ${e.message}</li></ul>`;
            } finally {
                btn.disabled = false;
                btn.textContent = 'Фикс в 1 клик';
            }
        }

        // Скачивание JSON
        function downloadTemplate() {
            try {
                const json = JSON.parse(editor.getValue());
                if (Array.isArray(json)) {
                    document.getElementById('errorOutput').innerHTML = `<ul><li>Ошибка: Введите один шаблон (объект JSON), а не массив</li></ul>`;
                    return;
                }
                const manufacturer = (json.manufacturer || 'unknown').replace(/\s+/g, '_');
                const model = (json.model || 'unknown').replace(/\s+/g, '_');
                const filename = `${manufacturer}_${model}.json`;
                const blob = new Blob([JSON.stringify(json, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
            } catch (e) {
                document.getElementById('errorOutput').innerHTML = `<ul><li>Ошибка скачивания: ${e.message}</li></ul>`;
            }
        }

        // --- Автокомплит по схеме ---
        function getCurrentJsonPath(cm) {
            // Получить путь в JSON по позиции курсора (с поддержкой индексов массивов)
            try {
                const pos = cm.getCursor();
                const lines = cm.getValue().split('\n');
                let upto = lines.slice(0, pos.line + 1).join('\n');
                upto = upto.slice(0, upto.length - (lines[pos.line].length - pos.ch));
                
                let path = [];
                let stack = [];
                let currentKey = '';
                let inString = false;
                let escape = false;
                let arrayIndex = 0;
                let inArray = false;
                let lastKey = '';
                
                // Анализируем текст до курсора
                for (let i = 0; i < upto.length; i++) {
                    const c = upto[i];
                    
                    if (escape) { 
                        escape = false; 
                        continue; 
                    }
                    if (c === '\\') { 
                        escape = true; 
                        continue; 
                    }
                    
                    if (c === '"') { 
                        inString = !inString; 
                        continue; 
                    }
                    
                    if (!inString) {
                        if (c === '{') {
                            stack.push('object');
                            inArray = false;
                            continue;
                        }
                        if (c === '[') {
                            stack.push('array');
                            inArray = true;
                            arrayIndex = 0;
                            continue;
                        }
                        if (c === '}') {
                            if (stack.length > 0 && stack[stack.length - 1] === 'object') {
                                stack.pop();
                                inArray = false;
                                // Очищаем путь при выходе из объекта, если мы вернулись в корень
                                if (stack.length <= 1) {
                                    path = [];
                                }
                            }
                            continue;
                        }
                        if (c === ']') {
                            if (stack.length > 0 && stack[stack.length - 1] === 'array') {
                                stack.pop();
                                inArray = stack.length > 0 && stack[stack.length - 1] === 'array';
                            }
                            continue;
                        }
                        if (c === ':') {
                            if (currentKey.trim()) {
                                lastKey = currentKey.trim().replace(/"/g, '');
                                path.push(lastKey);
                                currentKey = '';
                            }
                            continue;
                        }
                        if (c === ',') {
                            if (inArray && stack.length > 0 && stack[stack.length - 1] === 'array') {
                                arrayIndex++;
                            }
                            currentKey = '';
                            continue;
                        }
                    }
                    
                    if (inString) {
                        currentKey += c;
                    }
                }
                
                // Если мы в массиве и есть текущий индекс, добавляем его
                if (inArray && stack.length > 0 && stack[stack.length - 1] === 'array') {
                    path.push(arrayIndex);
                }
                
                // Проверяем, находимся ли мы в корневом объекте
                // Если stack содержит только корневой объект и мы на новой строке
                if (stack.length <= 1) {
                    const currentLine = lines[pos.line];
                    const beforeCursor = currentLine.slice(0, pos.ch);
                    const afterCursor = currentLine.slice(pos.ch);
                    
                    // Если перед курсором только пробелы и запятая, и после курсора ничего или только пробелы
                    // то мы в корневом объекте, вводим новое поле
                    if (/^\s*,?\s*$/.test(beforeCursor) && /^\s*$/.test(afterCursor)) {
                        path = [];
                    }
                }
                
                return path;
            } catch (e) { 
                console.error('Error in getCurrentJsonPath:', e);
                return []; 
            }
        }

        function getHintsForPath(path, tree) {
            let node = tree;
            
            // Если путь пустой, возвращаем корневые свойства
            if (path.length === 0) {
                return node;
            }
            
            // Обрабатываем путь по частям
            for (let i = 0; i < path.length; i++) {
                const p = path[i];
                
                if (typeof p === 'number') {
                    // Индекс массива - пропускаем, но запоминаем контекст
                    continue;
                }
                
                // Специальная обработка для link
                if (p === 'link') {
                    if (schema && schema.definitions && schema.definitions.link && schema.definitions.link.properties) {
                        node = schema.definitions.link.properties;
                        // Останавливаемся здесь, не обрабатываем дальнейшие части пути
                        break;
                    }
                }
                
                // Специальная обработка для characteristics
                if (p === 'characteristics') {
                    if (schema && schema.definitions && schema.definitions.characteristic && schema.definitions.characteristic.properties) {
                        node = schema.definitions.characteristic.properties;
                        // Останавливаемся здесь, не обрабатываем дальнейшие части пути
                        break;
                    }
                }
                
                // Специальная обработка для options
                if (p === 'options') {
                    if (schema && schema.definitions && schema.definitions.characteristic && schema.definitions.characteristic.properties) {
                        node = schema.definitions.characteristic.properties;
                    }
                } else if (servicesIndex !== -1) {
                    // Мы в services
                    if (schema && schema.properties && schema.properties.services && 
                        schema.properties.services.items && schema.properties.services.items.properties) {
                        node = schema.properties.services.items.properties;
                    }
                }
                
                // Обычное свойство
                if (node && node[p]) {
                    // Если у свойства есть вложенные properties, используем их
                    if (node[p].properties) {
                        node = node[p].properties;
                    } else {
                        // Иначе используем само свойство
                        node = node[p];
                    }
                } else {
                    break;
                }
            }
            
            return node;
        }

        CodeMirror.registerHelper('hint', 'json', function(cm) {
            if (!schemaHintsTree) return;
            const cur = cm.getCursor();
            const token = cm.getTokenAt(cur);
            const path = getCurrentJsonPath(cm);
            
            // Получаем текущий ввод пользователя для фильтрации
            let currentWord = '';
            let keyStart = cur.ch, keyEnd = cur.ch;
            const line = cm.getLine(cur.line);
            if (token && token.string && token.type === 'string') {
                // Внутри кавычек
                currentWord = token.string.replace(/^"|"$/g, '');
                keyStart = token.start;
                keyEnd = token.end;
            } else {
                // Вне кавычек — ищем последнее "слово" до курсора
                const before = line.slice(0, cur.ch);
                const match = before.match(/([\w$]+)$/);
                if (match) {
                    currentWord = match[1];
                    keyStart = cur.ch - currentWord.length;
                } else {
                    currentWord = '';
                    keyStart = cur.ch;
                }
                // ищем конец слова после курсора
                const after = line.slice(cur.ch);
                const matchAfter = after.match(/^([\w$]*)/);
                if (matchAfter) {
                    keyEnd = cur.ch + matchAfter[1].length;
                } else {
                    keyEnd = cur.ch;
                }
            }
            
            // Определяем текущий ключ для значения
            let key = null;
            if (path.length > 0) {
                key = path[path.length - 1];
            }
            
            // Инициализируем node в начале
            let node = null;
            
            // Определяем контекст для всех случаев
            const servicesIndex = path.lastIndexOf('services');
            const characteristicsIndex = path.lastIndexOf('characteristics');
            const linkIndex = path.lastIndexOf('link');
            const optionsIndex = path.lastIndexOf('options');
            
            // Более точное определение контекста
            // Проверяем, находимся ли мы внутри link в options или characteristics
            let isInLinkContext = false;
            if (linkIndex !== -1) {
                // Проверяем, есть ли после linkIndex еще поля, которые не относятся к link
                const pathAfterLink = path.slice(linkIndex + 1);
                const linkSchemaFields = ['scale', 'events', 'data', 'map', 'outMap', 'setProp', 'getProp', 'inFunc', 'outFunc', 'id', 'action', 'in', 'type', 'subType', 'topicGet', 'topicSet', 'checkValue', 'minValue', 'maxValue', 'minStep', 'format', 'getBLE', 'getStatus', 'set', 'get', 'getMethod', 'setMethod', 'getCommand', 'setCommand', 'endpoint', 'cluster', 'attribute', 'command', 'sendCommand', 'source', 'group', 'manufacturerCode', 'param', 'output', 'extAttribute', 'ClusterSpecificCommand', 'frameType', 'waitResponse', 'read', 'write', 'value', 'address', 'function', 'pollingTime', 'length', 'byteOrder', 'class', 'delimiter', 'bitmask', 'description'];
                
                // Если после link идут поля, которые не относятся к link схеме, то мы не в link контексте
                const hasNonLinkFields = pathAfterLink.some(field => !linkSchemaFields.includes(field));
                isInLinkContext = !hasNonLinkFields;
            }
            
            if (isInLinkContext) {
                // Мы в link контексте - определяем, в каком именно link
                if (optionsIndex !== -1 && linkIndex > optionsIndex) {
                    // Мы в options[].link - используем схему link
                    if (schema && schema.definitions && schema.definitions.link && schema.definitions.link.properties) {
                        node = schema.definitions.link.properties;
                    }
                } else if (characteristicsIndex !== -1 && linkIndex > characteristicsIndex) {
                    // Мы в characteristics[].link - используем схему link
                    if (schema && schema.definitions && schema.definitions.link && schema.definitions.link.properties) {
                        node = schema.definitions.link.properties;
                    }
                } else {
                    // Мы в link на корневом уровне - используем схему link
                    if (schema && schema.definitions && schema.definitions.link && schema.definitions.link.properties) {
                        node = schema.definitions.link.properties;
                    }
                }
            } else if (optionsIndex !== -1) {
                // Мы в options - используем схему characteristic
                if (schema && schema.definitions && schema.definitions.characteristic && schema.definitions.characteristic.properties) {
                    node = schema.definitions.characteristic.properties;
                }
            } else if (characteristicsIndex !== -1) {
                // Мы в characteristics
                if (schema && schema.definitions && schema.definitions.characteristic && schema.definitions.characteristic.properties) {
                    node = schema.definitions.characteristic.properties;
                }
            } else if (servicesIndex !== -1) {
                // Мы в services
                if (schema && schema.properties && schema.properties.services && 
                    schema.properties.services.items && schema.properties.services.items.properties) {
                    node = schema.properties.services.items.properties;
                }
            } else {
                // Мы в корневых свойствах - используем schemaHintsTree напрямую
                node = schemaHintsTree;
            }
            
            
            // Универсальная функция для проверки, находимся ли мы в значении поля
            function isInValuePosition() {
                const before = line.slice(0, cur.ch);
                
                // Проверяем различные сценарии
                if (token && token.state && token.state.lastType === 'colon') return true;
                if (token && token.type === 'string') return true;
                
                // После двоеточия с пробелами (включая 0)
                if (/:\s*$/.test(before)) return true;
                
                // Внутри кавычек после двоеточия
                if (/:\s*"/.test(before) && token && token.type === 'string') return true;
                
                // После двоеточия с пробелами и текстом (но не в кавычках)
                if (/:\s+\S/.test(before) && !/:\s*"/.test(before)) return true;
                
                return false;
            }
            
            // Универсальная функция для создания списка подсказок
            function createValueSuggestions(values, wrapInQuotes = true) {
                return values.map(v => {
                    return {
                        text: wrapInQuotes ? `"${v}"` : v,
                        displayText: v,
                        hint: function(cm, data, completion) {
                            cm.replaceRange(wrapInQuotes ? `"${v}"` : v, {line: cur.line, ch: keyStart}, {line: cur.line, ch: keyEnd});
                        }
                    };
                });
            }
            
            // Если мы в значении поля и у нас есть текущий ключ
            if (isInValuePosition() && key && node && node[key]) {
                const field = node[key];
                
                // Обработка enum полей (универсально для всех полей с enum)
                if (field.enum && field.enum.length > 0) {
                    let enumList = createValueSuggestions(field.enum, true);
                    // Фильтрация по текущему вводу (если есть)
                    if (currentWord && currentWord.length > 0) {
                        enumList = enumList.filter(item => item.displayText.toLowerCase().includes(currentWord.toLowerCase()));
                    }
                    return {
                        list: enumList,
                        from: keyStart,
                        to: keyEnd,
                        completeSingle: false
                    };
                }
                
                // Обработка boolean полей
                if (field.type === 'boolean') {
                    let booleanList = createValueSuggestions(['true', 'false'], false);
                    // Фильтрация по текущему вводу (если есть)
                    if (currentWord && currentWord.length > 0) {
                        booleanList = booleanList.filter(item => item.displayText.toLowerCase().includes(currentWord.toLowerCase()));
                    }
                    return {
                        list: booleanList,
                        from: keyStart,
                        to: keyEnd,
                        completeSingle: false
                    };
                }
                
                // Обработка строковых полей (без enum)
                if (field.type === 'string' && !field.enum) {
                    let stringList = createValueSuggestions([''], true);
                    // Фильтрация по текущему вводу (если есть)
                    if (currentWord && currentWord.length > 0) {
                        stringList = stringList.filter(item => item.displayText.toLowerCase().includes(currentWord.toLowerCase()));
                    }
                    return {
                        list: stringList,
                        from: keyStart,
                        to: keyEnd,
                        completeSingle: false
                    };
                }
                
                // Обработка объектных полей
                if (field.type === 'object') {
                    let objectList = createValueSuggestions(['{}'], false);
                    // Фильтрация по текущему вводу (если есть)
                    if (currentWord && currentWord.length > 0) {
                        objectList = objectList.filter(item => item.displayText.toLowerCase().includes(currentWord.toLowerCase()));
                    }
                    return {
                        list: objectList,
                        from: keyStart,
                        to: keyEnd,
                        completeSingle: false
                    };
                }
                
                // Обработка массивных полей
                if (field.type === 'array' || (Array.isArray(field.type) && field.type.includes('array'))) {
                    let arrayList = createValueSuggestions(['[]'], false);
                    // Фильтрация по текущему вводу (если есть)
                    if (currentWord && currentWord.length > 0) {
                        arrayList = arrayList.filter(item => item.displayText.toLowerCase().includes(currentWord.toLowerCase()));
                    }
                    return {
                        list: arrayList,
                        from: keyStart,
                        to: keyEnd,
                        completeSingle: false
                    };
                }
                
                // Если у поля есть подсказки для значений, не показываем ключи
                return { list: [], from: keyStart, to: keyEnd, completeSingle: false };
            }
            
            // Ключи - используем обычную логику
            const list = [];
            if (node) { // Добавляем проверку на null
                for (const key in node) {
                    if (Object.prototype.hasOwnProperty.call(node, key)) {
                        if (currentWord && currentWord.length > 0 && !key.toLowerCase().includes(currentWord.toLowerCase())) continue;
                        const item = node[key];
                        let displayText = key;
                        if (item && item.type) displayText += ` (${item.type})`;
                        if (item && item.enum) displayText += ` [${item.enum.join(', ')}]`;
                        list.push({
                            text: key,
                            displayText: displayText,
                            render: function(el, self, data) {
                                el.innerHTML = `<span style='font-weight:bold'>${key}</span> <span style='color:#888'>${item && item.type ? item.type : ''}</span> <span style='color:#0a0'>${item && item.enum ? '['+item.enum.join(', ')+']' : ''}</span><br><span style='font-size:smaller;color:#888'>${item && item.description ? item.description : ''}</span>`;
                            },
                            hint: function(cm, data, completion) {
                                // Заменяем всё, что пользователь начал вводить (и кавычки, и текст, и просто слово)
                                cm.replaceRange('"' + key + '": ', {line: cur.line, ch: keyStart}, {line: cur.line, ch: keyEnd});
                            }
                        });
                    }
                }
            }
            
            // Сортируем список по алфавиту
            list.sort((a, b) => a.text.localeCompare(b.text));
            
            let from = keyStart;
            let to = keyEnd;
            return {
                list: list,
                from,
                to,
                completeSingle: false
            };
        });

        editor.on('inputRead', function(cm, change) {
            if (change.text[0] && /[\w\{\[\:"]/.test(change.text[0])) {
                cm.showHint({completeSingle: false});
            }
            // Дополнительно вызываем автокомплит при вводе пробела после двоеточия
            if (change.text[0] === ' ') {
                const cur = cm.getCursor();
                const line = cm.getLine(cur.line);
                const before = line.slice(0, cur.ch);
                if (/:\s*$/.test(before)) {
                    setTimeout(() => cm.showHint({completeSingle: false}), 10);
                }
            }
        });

        // Обратный отсчёт до 28.06.2025 20:00 МСК
        (function() {
            // МСК = UTC+3
            const targetDate = new Date(Date.UTC(2025, 5, 28, 17, 0, 0)); // 28 июня 2025, 20:00 МСК = 17:00 UTC
            const timerEl = document.getElementById('countdownTimer');
            function updateCountdown() {
                const now = new Date();
                const diff = targetDate - now;
                if (diff <= 0) {
                    timerEl.textContent = '00д 00ч 00м 00с';
                    return;
                }
                const days = Math.floor(diff / (1000 * 60 * 60 * 24));
                const hours = Math.floor((diff / (1000 * 60 * 60)) % 24);
                const mins = Math.floor((diff / (1000 * 60)) % 60);
                const secs = Math.floor((diff / 1000) % 60);
                timerEl.textContent = `${days.toString().padStart(2,'0')}д ${hours.toString().padStart(2,'0')}ч ${mins.toString().padStart(2,'0')}м ${secs.toString().padStart(2,'0')}с`;
            }
            updateCountdown();
            setInterval(updateCountdown, 1000);
        })();
    </script>
</body>
</html>